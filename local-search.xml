<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue-class-component 源码解析</title>
    <link href="/2023/08/a360ef5f1032.html"/>
    <url>/2023/08/a360ef5f1032.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; componentFactory, $internalHooks &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component&#x27;</span>;<br><span class="hljs-comment">// createDecorator 用于创建自定义的装饰器</span><br><span class="hljs-keyword">export</span> &#123; createDecorator, mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// typeof Class === &#x27;function&#x27;  true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 如果options是一个累的情况</span><br>      <span class="hljs-comment">// 则是 @Component 直接走工厂函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">componentFactory</span>(options);<br>    &#125;<br>  <span class="hljs-comment">// 如果是Component(&#123;</span><br>  <span class="hljs-comment">//// 所有的组件选项都可以放在这里</span><br>  <span class="hljs-comment">//  template: `&lt;div&gt;&lt;/div&gt;`</span><br><span class="hljs-comment">// &#125;)</span><br>  <span class="hljs-comment">// 这种结构 则闭包配置参数 此时的配置参数就是options 接收到的类是Component</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">Component</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">componentFactory</span>(<span class="hljs-title class_">Component</span>, options);<br>    &#125;;<br>&#125;<br><span class="hljs-comment">// registerHooks 用于注册别的第三方的hooks 例如 vue-router的hooks</span><br><span class="hljs-title class_">Component</span>.<span class="hljs-property">registerHooks</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerHooks</span>(<span class="hljs-params">keys</span>) &#123;<br>    $internalHooks.<span class="hljs-title function_">push</span>(...keys);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Component</span>;<br></code></pre></td></tr></table></figure><p>再次继续分析 <code>componentFactory</code>包的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> $internalHooks = [<br>  <span class="hljs-string">&#x27;data&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeCreate&#x27;</span>,<br>  <span class="hljs-string">&#x27;created&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeMount&#x27;</span>,<br>  <span class="hljs-string">&#x27;mounted&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeDestroy&#x27;</span>,<br>  <span class="hljs-string">&#x27;destroyed&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>,<br>  <span class="hljs-string">&#x27;updated&#x27;</span>,<br>  <span class="hljs-string">&#x27;activated&#x27;</span>,<br>  <span class="hljs-string">&#x27;deactivated&#x27;</span>,<br>  <span class="hljs-string">&#x27;render&#x27;</span>,<br>  <span class="hljs-string">&#x27;errorCaptured&#x27;</span>,<br>  <span class="hljs-string">&#x27;serverPrefetch&#x27;</span>, <span class="hljs-comment">// 2.6</span><br>]<br><br><span class="hljs-comment">// componentFactory函数的作用就是将我们class 声明的类中的属性转换成options的形式</span><br><span class="hljs-comment">//options 就是我们平时写的export default &#123;&#125;  的对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentFactory</span>(<span class="hljs-params">Component, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-comment">// vue 组件的名字</span><br>  options.<span class="hljs-property">name</span> = options.<span class="hljs-property">name</span> || <span class="hljs-title class_">Component</span>.<span class="hljs-property">_componentTag</span> || <span class="hljs-title class_">Component</span>.<span class="hljs-property">name</span><br>  <span class="hljs-comment">// 获取类的实例属性</span><br>  <span class="hljs-comment">// prototype props.</span><br>  <span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-comment">// 获取原型上的所有的可以枚举或者不可枚举的所有属性值 进行遍历</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(proto).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;constructor&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 如果存在hooks选择 例如options中的beforeRouteEnter 这种hook 就会被添加到 options中</span><br>    <span class="hljs-keyword">if</span> ($internalHooks.<span class="hljs-title function_">indexOf</span>(key) &gt; -<span class="hljs-number">1</span>) &#123;<br>      options[key] = proto[key]<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// getOwnPropertyDescriptor 获取该对象上的属性的操作符 而不获取原形链上的操作符</span><br>    <span class="hljs-comment">// 因此可能获取到的key为 undefined</span><br>    <span class="hljs-keyword">const</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(proto, key)<br>    <span class="hljs-comment">// void 0 === undefined // true</span><br>    <span class="hljs-keyword">if</span> (descriptor.<span class="hljs-property">value</span> !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// methods</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        ;(options.<span class="hljs-property">methods</span> || (options.<span class="hljs-property">methods</span> = &#123;&#125;))[key] = descriptor.<span class="hljs-property">value</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 因为ts用的class 继承的关系 这里获取到的属性都是实力对象身上的属性 也就是</span><br>        <span class="hljs-comment">// options中的data的返回值的属性</span><br>        <span class="hljs-comment">// typescript decorated data</span><br>        ;(options.<span class="hljs-property">mixins</span> || (options.<span class="hljs-property">mixins</span> = [])).<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123; [key]: descriptor.<span class="hljs-property">value</span> &#125;<br>          &#125;,<br>        &#125;)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (descriptor.<span class="hljs-property">get</span> || descriptor.<span class="hljs-property">set</span>) &#123;<br>      <span class="hljs-comment">// 当前的属性如果实现了 get 或者 set方法 则是一个计算属性</span><br>      <span class="hljs-comment">// computed properties</span><br>      ;(options.<span class="hljs-property">computed</span> || (options.<span class="hljs-property">computed</span> = &#123;&#125;))[key] = &#123;<br>        <span class="hljs-attr">get</span>: descriptor.<span class="hljs-property">get</span>,<br>        <span class="hljs-attr">set</span>: descriptor.<span class="hljs-property">set</span>,<br>      &#125;<br>    &#125;<br>  &#125;)<br>  ;(options.<span class="hljs-property">mixins</span> || (options.<span class="hljs-property">mixins</span> = [])).<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// collectDataFromConstructor的作用就是区别我们定义的data 和</span><br>      <span class="hljs-comment">// （方法 属性以及vue的自有属性）的区别</span><br>      <span class="hljs-comment">// 将data从类中提取出来</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">collectDataFromConstructor</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Component</span>)<br>    &#125;,<br>  &#125;)<br>  <span class="hljs-comment">// decorate options</span><br>  <span class="hljs-comment">// 这里用于创建自定义的装饰器</span><br>  <span class="hljs-keyword">const</span> decorators = <span class="hljs-title class_">Component</span>.<span class="hljs-property">__decorators__</span><br>  <span class="hljs-keyword">if</span> (decorators) &#123;<br>    decorators.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(options))<br>    <span class="hljs-keyword">delete</span> <span class="hljs-title class_">Component</span>.<span class="hljs-property">__decorators__</span><br>  &#125;<br>  <span class="hljs-comment">// find super</span><br><span class="hljs-comment">// Component.prototype.__proto__ === (所继承的直父类).prototype</span><br>  <span class="hljs-keyword">const</span> superProto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Super</span> = superProto <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vue</span> ? superProto.<span class="hljs-property">constructor</span> : <span class="hljs-title class_">Vue</span><br>  <span class="hljs-comment">// 创建一个vue的子类</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Extended</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">extend</span>(options)<br>  <span class="hljs-comment">// forwardStaticMembers如下</span><br>  <span class="hljs-title function_">forwardStaticMembers</span>(<span class="hljs-title class_">Extended</span>, <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Super</span>)<br>  <span class="hljs-comment">// 如果支持反射 则将组件反射收集的值也映射到 vue的实例对象上</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">reflectionIsSupported</span>()) &#123;<br>    <span class="hljs-title function_">copyReflectionMetadata</span>(<span class="hljs-title class_">Extended</span>, <span class="hljs-title class_">Component</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Extended</span><br>&#125;<br><span class="hljs-keyword">const</span> reservedPropertyNames = [<br>    <span class="hljs-comment">// Unique id</span><br>    <span class="hljs-string">&#x27;cid&#x27;</span>,<br>    <span class="hljs-comment">// Super Vue constructor</span><br>    <span class="hljs-string">&#x27;super&#x27;</span>,<br>    <span class="hljs-comment">// Component options that will be used by the component</span><br>    <span class="hljs-string">&#x27;options&#x27;</span>,<br>    <span class="hljs-string">&#x27;superOptions&#x27;</span>,<br>    <span class="hljs-string">&#x27;extendOptions&#x27;</span>,<br>    <span class="hljs-string">&#x27;sealedOptions&#x27;</span>,<br>    <span class="hljs-comment">// Private assets</span><br>    <span class="hljs-string">&#x27;component&#x27;</span>,<br>    <span class="hljs-string">&#x27;directive&#x27;</span>,<br>    <span class="hljs-string">&#x27;filter&#x27;</span><br>];<br><span class="hljs-keyword">const</span> shouldIgnore = &#123;<br>    <span class="hljs-attr">prototype</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">arguments</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">callee</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">caller</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-comment">//这个方法的作用是将Component的静态类型转发到vue创建子类的身上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">forwardStaticMembers</span>(<span class="hljs-params">Extended, Original, Super</span>) &#123;<br>    <span class="hljs-comment">// We have to use getOwnPropertyNames since Babel registers methods as non-enumerable</span><br><span class="hljs-comment">// 遍历原Component的每一个静态实例</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Original</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// Skip the properties that should not be overwritten</span><br>        <span class="hljs-keyword">if</span> (shouldIgnore[key]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Some browsers does not allow reconfigure built-in properties</span><br>        <span class="hljs-keyword">const</span> extendedDescriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Extended</span>, key);<br>      <span class="hljs-comment">// 如果实例在vue子类上存在了并且不可以改变配置 则直接return</span><br>        <span class="hljs-keyword">if</span> (extendedDescriptor &amp;&amp; !extendedDescriptor.<span class="hljs-property">configurable</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Original</span>, key);<br>        <span class="hljs-comment">// If the user agent does not support `__proto__` or its family (IE &lt;= 10),</span><br>        <span class="hljs-comment">// the sub class properties may be inherited properties from the super class in TypeScript.</span><br>        <span class="hljs-comment">// We need to exclude such properties to prevent to overwrite</span><br>        <span class="hljs-comment">// the component options object which stored on the extended constructor (See #192).</span><br>        <span class="hljs-comment">// If the value is a referenced value (object or function),</span><br>        <span class="hljs-comment">// we can check equality of them and exclude it if they have the same reference.</span><br>        <span class="hljs-comment">// If it is a primitive value, it will be forwarded for safety.</span><br>        <span class="hljs-keyword">if</span> (!hasProto) &#123;<br>            <span class="hljs-comment">// Only `cid` is explicitly exluded from property forwarding</span><br>            <span class="hljs-comment">// because we cannot detect whether it is a inherited property or not</span><br>            <span class="hljs-comment">// on the no `__proto__` environment even though the property is reserved.</span><br>            <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;cid&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">const</span> superDescriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Super</span>, key);<br>          <span class="hljs-comment">// 如果是一个基本的数据类型 并且环境并不支持__proto__ 的形式 子类和父类都有相同的引用 则将其排除</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPrimitive</span>(descriptor.<span class="hljs-property">value</span>) &amp;&amp;<br>                superDescriptor &amp;&amp;<br>                superDescriptor.<span class="hljs-property">value</span> === descriptor.<span class="hljs-property">value</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Warn if the users manually declare reserved properties</span><br>        <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>            reservedPropertyNames.<span class="hljs-title function_">indexOf</span>(key) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Static property name &#x27;<span class="hljs-subst">$&#123;key&#125;</span>&#x27; declared on class &#x27;<span class="hljs-subst">$&#123;Original.name&#125;</span>&#x27; `</span> +<br>                <span class="hljs-string">&#x27;conflicts with reserved property name of Vue internal. &#x27;</span> +<br>                <span class="hljs-string">&#x27;It may cause unexpected behavior of the component. Consider renaming the property.&#x27;</span>);<br>        &#125;<br>      <span class="hljs-comment">// 这里将静态属性以及配置转移到vue.extend 出来的子类中了</span><br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Extended</span>, key, descriptor);<br>    &#125;);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>collectDataFromConstructor 函数的解释</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; warn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">collectDataFromConstructor</span>(<span class="hljs-params">vm, Component</span>) &#123;<br>    <span class="hljs-comment">// override _init to prevent to init as Vue instance</span><br>  <span class="hljs-comment">// 这里重写了vue在constructor中的_init函数</span><br>    <span class="hljs-keyword">const</span> originalInit = <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span>;<br>    <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// proxy to actual vm</span><br>      <span class="hljs-comment">// 获取vue实例上的所有属性集合 是 $options _uid 方法等参数 对其进行数据劫持</span><br>      <span class="hljs-comment">// 后续为了使其不可遍历</span><br>        <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(vm);<br>        <span class="hljs-comment">// 2.2.0 compat (props are no longer exposed as self properties)</span><br>        <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!vm.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>                    keys.<span class="hljs-title function_">push</span>(key);<br>                &#125;<br>            &#125;<br>        &#125;<br>        keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>          <span class="hljs-comment">// ie8对于访问器属性描述符，configurable 必须设置为 true，enumerable 必须设置为 false</span><br>          <span class="hljs-comment">// 这里设置了configurable（configurable 默认为false）</span><br>          <span class="hljs-comment">// 后续的init操作后 会将这些属性加上不可遍历的</span><br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, key, &#123;<br>                <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> vm[key],<br>                <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123; vm[key] = value; &#125;,<br>                <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>            &#125;);<br>        &#125;);<br>    &#125;;<br>    <span class="hljs-comment">// should be acquired class property values</span><br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>();<br>    <span class="hljs-comment">// restore original _init to avoid memory leak (#209)</span><br>    <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = originalInit;<br>    <span class="hljs-comment">// create plain data object</span><br>    <span class="hljs-keyword">const</span> plainData = &#123;&#125;;<br>  <span class="hljs-comment">// new 出来的对象中的props 方法 以及vue的一些属性都被添加上了不可枚举的属性</span><br>  <span class="hljs-comment">// 因此这里的枚举出来的data就是所需要的data</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (data[key] !== <span class="hljs-literal">undefined</span>) &#123;<br>            plainData[key] = data[key];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vue</span>) &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(plainData).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Component class must inherit Vue or its descendant class &#x27;</span> +<br>                <span class="hljs-string">&#x27;when class property is used.&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> plainData;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>relect.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills</span><br><span class="hljs-comment">// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.</span><br><span class="hljs-comment">// Without this check consumers will encounter hard to track down runtime errors.</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reflectionIsSupported</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">defineMetadata</span> &amp;&amp; <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">getOwnMetadataKeys</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">copyReflectionMetadata</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-title function_">forwardMetadata</span>(to, <span class="hljs-keyword">from</span>);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">forwardMetadata</span>(to.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-keyword">from</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, key);<br>    &#125;);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-keyword">from</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">forwardMetadata</span>(to, <span class="hljs-keyword">from</span>, key);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">forwardMetadata</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, propertyKey</span>) &#123;<br>    <span class="hljs-keyword">const</span> metaKeys = propertyKey<br>        ? <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnMetadataKeys</span>(<span class="hljs-keyword">from</span>, propertyKey)<br>        : <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnMetadataKeys</span>(<span class="hljs-keyword">from</span>);<br>    metaKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">metaKey</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> metadata = propertyKey<br>            ? <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnMetadata</span>(metaKey, <span class="hljs-keyword">from</span>, propertyKey)<br>            : <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnMetadata</span>(metaKey, <span class="hljs-keyword">from</span>);<br>        <span class="hljs-keyword">if</span> (propertyKey) &#123;<br>            <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(metaKey, metadata, to, propertyKey);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(metaKey, metadata, to);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h1><blockquote><p>内置工具类的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">noop</span> = (<span class="hljs-params"></span>) =&gt; &#123; &#125;;<br><span class="hljs-keyword">const</span> fakeArray = &#123; <span class="hljs-attr">__proto__</span>: [] &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hasProto = fakeArray <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createDecorator</span>(<span class="hljs-params">factory</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, key, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ctor</span> = <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span><br>            ? target<br>            : target.<span class="hljs-property">constructor</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Ctor</span>.<span class="hljs-property">__decorators__</span>) &#123;<br>            <span class="hljs-title class_">Ctor</span>.<span class="hljs-property">__decorators__</span> = [];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> index !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>            index = <span class="hljs-literal">undefined</span>;<br>        &#125;<br>        <span class="hljs-title class_">Ctor</span>.<span class="hljs-property">__decorators__</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function"><span class="hljs-params">options</span> =&gt;</span> <span class="hljs-title function_">factory</span>(options, key, index));<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mixins</span>(<span class="hljs-params">...Ctors</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123; <span class="hljs-attr">mixins</span>: <span class="hljs-title class_">Ctors</span> &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrimitive</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> value;<br>    <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> || (type !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; type !== <span class="hljs-string">&#x27;function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;[vue-class-component] &#x27;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整理JavaScript数组去重的种种方法</title>
    <link href="/2023/03/2efe13c3f3c6.html"/>
    <url>/2023/03/2efe13c3f3c6.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>数组去重是个相对于简单的需求，但是其比较考验编程人员对 Javascript 对数组 API 以及数据类型的熟悉程度。</p><p>去重的目标数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;花花&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小明&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;NaN&quot;</span>, <span class="hljs-literal">undefined</span>, obj2, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-number">1</span>, obj1, <span class="hljs-literal">null</span>, obj1, obj2 ];<br></code></pre></td></tr></table></figure><h1 id="2-使用-Javascript-中某些数据类型的值不会重复的特性进行去重"><a href="#2-使用-Javascript-中某些数据类型的值不会重复的特性进行去重" class="headerlink" title="2. 使用 Javascript 中某些数据类型的值不会重复的特性进行去重"></a>2. 使用 Javascript 中某些数据类型的值不会重复的特性进行去重</h1><h2 id="2-1-使用-Set-结构"><a href="#2-1-使用-Set-结构" class="headerlink" title="2.1 使用 Set 结构"></a>2.1 使用 Set 结构</h2><p>使用 Set 结构进行数组去重是 ES6 环境下最为推荐的方式，其特性就是不允许数组中出现重复的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueBySet</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null, NaN, &#123; name: <span class="hljs-symbol">&#x27;花花</span>&#x27; &#125; ]<br></code></pre></td></tr></table></figure><p>甚至还可以更加精简：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<br></code></pre></td></tr></table></figure><h2 id="2-2-使用-Object-keys-特性"><a href="#2-2-使用-Object-keys-特性" class="headerlink" title="2.2 使用 Object keys 特性"></a>2.2 使用 Object keys 特性</h2><p>一个 Object 不允许有相同的键值，因此我们可以用其特性进行去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByObject</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (!obj[item]) &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>      obj[item] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>但是由于 Object Key 只能为字符串，所以无法分辨 Number 与 String 的区别，并且无法分别引用类型的数据（因为会被转为 “[object Object]” 类似的字符串）。</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null ]<br></code></pre></td></tr></table></figure><p>如果我们将其键值存储为 <code>typeof item + item</code> 那么，<code>&quot;1&quot;</code> 被存入为键值的时候就会成为 <code>&quot;string1&quot;</code>，<code>1</code> 被存为键值的时候就会成为 <code>&quot;number1&quot;</code>，这样就能区分 Number 与 String 了。同时我们还可以使用 <code>Object.prototype.hasOwnProperty()</code> 来判断创建的对象是否有某一属性，这样更为严谨：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByHasOwnProperty</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-keyword">typeof</span> item + item)<br>      ? <span class="hljs-literal">false</span><br>      : (obj[<span class="hljs-keyword">typeof</span> item + item] = <span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>但是此时我们仍无法区分引用类型</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null, NaN ]<br></code></pre></td></tr></table></figure><h2 id="2-3-使用-Map-keys-特性"><a href="#2-3-使用-Map-keys-特性" class="headerlink" title="2.3 使用 Map keys 特性"></a>2.3 使用 Map keys 特性</h2><p>Map 结构优于 Object 结构的是其键值可以存放对象，这样就可以完美应用于数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByMap</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    map.<span class="hljs-title function_">set</span>(item, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// map.keys() 返回的是一个新的 Map iterator 对象，需要转换为数组再返回</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map.<span class="hljs-title function_">keys</span>());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null, NaN, &#123; name: <span class="hljs-symbol">&#x27;花花</span>&#x27; &#125; ]<br></code></pre></td></tr></table></figure><h1 id="3-for-循环嵌套去重"><a href="#3-for-循环嵌套去重" class="headerlink" title="3. for 循环嵌套去重"></a>3. for 循环嵌套去重</h1><p>这是最简单明了的一种去重方式，也是 ES5 环境下可以使用的去重方式，其利用 <code>splice()</code> 方法，会直接修改目标数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByFor</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) &#123;<br>        arr.<span class="hljs-title function_">splice</span>(j, <span class="hljs-number">1</span>);<br>        j--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 NaN &#x3D;&#x3D;&#x3D; NaN 结果为 false，所以其无法对 NaN 进行去重</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[ <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;NaN&#x27;</span>, undefined, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;花花&#x27;</span> &#125; ]<br></code></pre></td></tr></table></figure><h1 id="4-使用-indexOf-去重"><a href="#4-使用-indexOf-去重" class="headerlink" title="4. 使用 indexOf 去重"></a>4. 使用 indexOf 去重</h1><h2 id="3-1-单纯使用-indexOf"><a href="#3-1-单纯使用-indexOf" class="headerlink" title="3.1 单纯使用 indexOf"></a>3.1 单纯使用 indexOf</h2><p>使用 <code>Array.prototype.indexOf()</code> 方法可以检索元素的出现位置，更重要的是判断元素是否存在于某个数组中。</p><p>因此我们可以额外准备一个新数组，依次遍历目标数组，遍历时看当前遍历的元素是否在创建的新数组中，如果不存在就放入新数组，否则就不需要放入新数组，最终将这个新数组返回即可，且该方法可以用于 ES5 环境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByIndexOf</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-title function_">indexOf</span>(current) === -<span class="hljs-number">1</span>) &#123;<br>      result.<span class="hljs-title function_">push</span>(current);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 [NaN].indexOf(NaN) 结果为 -1，所以无法对 NaN 进行去重</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[ <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;NaN&#x27;</span>, undefined, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;花花&#x27;</span> &#125; ]<br></code></pre></td></tr></table></figure><h2 id="3-2-使用-includes-代替-indexOf-去重"><a href="#3-2-使用-includes-代替-indexOf-去重" class="headerlink" title="3.2 使用 includes 代替 indexOf 去重"></a>3.2 使用 includes 代替 indexOf 去重</h2><p>在 ES6 中引入了 <code>Array.prototype.includes()</code> 专门检测某元素是否存在于目标数组中，同时可以判断 <code>NaN</code> 类型，正好可以弥补单纯使用 <code>indexOf()</code> 进行去重的劣势：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByIncludes</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 利用 reducer 进一步简化代码</span><br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev, current</span>) &#123;<br>    <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">includes</span>(current) ? prev : [...prev, current];<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null, NaN, &#123; name: <span class="hljs-symbol">&#x27;花花</span>&#x27; &#125; ]<br></code></pre></td></tr></table></figure><h2 id="3-3-使用-filter-与-indexOf-去重"><a href="#3-3-使用-filter-与-indexOf-去重" class="headerlink" title="3.3 使用 filter 与 indexOf 去重"></a>3.3 使用 filter 与 indexOf 去重</h2><p>使用 <code>indexOf()</code> 还需要创建一个空数组，利用 ES6 的 <code>filter()</code> 方法可以免除创建一个新数组。同时其思想由原来的放入新数组，改为了判断当前遍历元素是否是数组中第一个出现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByFilter</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>    <span class="hljs-comment">// 看当前元素是否是数组中第一个出现的</span><br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 [NaN].indexOf(NaN) 结果为 -1，所以无法对 NaN 不再结果中</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;NaN</span>&#x27;, undefined, &#123; name: <span class="hljs-symbol">&#x27;小明</span>&#x27; &#125;, null, &#123; name: <span class="hljs-symbol">&#x27;花花</span>&#x27; &#125; ]<br></code></pre></td></tr></table></figure><h1 id="5-数组排序后去重（不稳定）"><a href="#5-数组排序后去重（不稳定）" class="headerlink" title="5. 数组排序后去重（不稳定）"></a>5. 数组排序后去重（不稳定）</h1><h2 id="5-1-使用-sort-去重"><a href="#5-1-使用-sort-去重" class="headerlink" title="5.1 使用 sort 去重"></a>5.1 使用 sort 去重</h2><p><code>Array.prototypr.sort()</code> 可以对数组进行排序，我们将数组排序后，重复的元素就会并列出现，因此可以直接遍历每个元素，如果当前元素与上一个元素并非重复，那就将其放入新数组，否则就略过，直至遍历完所有数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueBySort</span>(<span class="hljs-params">arr</span>) &#123;<br>  arr.<span class="hljs-title function_">sort</span>();<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 当前元素与前一个元素相比看是否相等</span><br>    <span class="hljs-comment">// 注意这里不能与后一个元素比是否相等，因为如果数组中存在 undefined 的话，arr[length + 1] 会与 undefined 相等，导致 undefined 不会被添加到数组中</span><br>    <span class="hljs-keyword">if</span> (arr[i] !== arr[i - <span class="hljs-number">1</span>]) &#123;<br>      result.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 sort 会将数字与字符串统一转换为数字，所以当数组中存在例如 [1, “1”, 1] 这样的元素时，会原封不动的将其排列为原有的顺序，导致后面去重失败，并且 sort 也无法对引用类型进行排序。同时由于去重前的对比操作基于 <code>===</code> 操作符的判断，因此对 NaN 类型也无法判断。</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<br>  <span class="hljs-number">1</span>,              <span class="hljs-string">&#x27;1&#x27;</span>,<br>  <span class="hljs-number">1</span>,              <span class="hljs-string">&#x27;NaN&#x27;</span>,<br>  <span class="hljs-keyword">NaN</span>,            <span class="hljs-keyword">NaN</span>,<br>  &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;花花&#x27;</span> &#125;,<br>  &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, <span class="hljs-keyword">null</span>,<br>  undefined<br>]<br></code></pre></td></tr></table></figure><h2 id="5-2-排序后用递归思想去重"><a href="#5-2-排序后用递归思想去重" class="headerlink" title="5.2 排序后用递归思想去重"></a>5.2 排序后用递归思想去重</h2><p>上一种方法还是要创建一个新数组，如果我们想要直接操作需要去重的数组，那么还需要一点递归思想：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueByRecursive</span>(<span class="hljs-params">arr</span>) &#123;<br>  arr.<span class="hljs-title function_">sort</span>();<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">index</span>) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (arr[index] === arr[index - <span class="hljs-number">1</span>]) &#123;<br>        arr.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-title function_">unique</span>(index - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">unique</span>(arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>劣势与上面一致</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<br>  <span class="hljs-number">1</span>,              <span class="hljs-string">&#x27;1&#x27;</span>,<br>  <span class="hljs-number">1</span>,              <span class="hljs-string">&#x27;NaN&#x27;</span>,<br>  <span class="hljs-keyword">NaN</span>,            <span class="hljs-keyword">NaN</span>,<br>  &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;花花&#x27;</span> &#125;,<br>  &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span> &#125;, <span class="hljs-keyword">null</span>,<br>  undefined<br>]<br></code></pre></td></tr></table></figure><h2 id="5-2-排序后用原地算法去重（仅适用于数字）"><a href="#5-2-排序后用原地算法去重（仅适用于数字）" class="headerlink" title="5.2 排序后用原地算法去重（仅适用于数字）"></a>5.2 排序后用原地算法去重（仅适用于数字）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqBySort</span>(<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> sortedNums = nums.<span class="hljs-title function_">sort</span>();<br>  <span class="hljs-comment">// 当前索引位置的元素期望是不重复的元素，同时改变量表示不重复元素的个数</span><br>  <span class="hljs-keyword">let</span> noRepeatIndex = nums.<span class="hljs-property">length</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sortedNums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> current = sortedNums[i];<br>    <span class="hljs-comment">// 如果当前元素比 noRepeatIndex-1 位置的元素要大，就将其放置到 noRepeatIndex 的位置上，并将 noRepeatIndex 向后指</span><br>    <span class="hljs-keyword">if</span> (current &gt; sortedNums[noRepeatIndex - <span class="hljs-number">1</span>]) &#123;<br>      sortedNums[noRepeatIndex] = current;<br>      noRepeatIndex++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sortedNums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, noRepeatIndex);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>数组去重并非是难题，但是里面坑比较多，需要注意以下几点：</p><ul><li>利用 object keys 去重的话，注意 keys 会被转换为字符串</li><li><code>indexOf()</code> 方法与 <code>===</code> 运算符都不能判断 NaN 类型</li><li><code>sort()</code> 方法对字符串与对象的排序会对后续去重产生影响</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 常用指令整理</title>
    <link href="/2023/01/496595df3131.html"/>
    <url>/2023/01/496595df3131.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1. 查看信息"></a>1. 查看信息</h1><h2 id="1-1-查看版本"><a href="#1-1-查看版本" class="headerlink" title="1.1 查看版本"></a>1.1 查看版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker version<br></code></pre></td></tr></table></figure><h2 id="1-2-查看系统信息"><a href="#1-2-查看系统信息" class="headerlink" title="1.2 查看系统信息"></a>1.2 查看系统信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker info<br></code></pre></td></tr></table></figure><h1 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h1><h2 id="2-1-创建-container"><a href="#2-1-创建-container" class="headerlink" title="2.1 创建 container"></a>2.1 创建 container</h2><p>docker 会先去查找本地 nginx 镜像，如果查找不到就会从远程下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container run [image name]<br></code></pre></td></tr></table></figure><p>将 container 内部的端口号映射到外部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container run -p [实体机端口]:[docker 内端口] [image name]<br><br>// eg:<br>docker container run -p 80:80 nginx<br></code></pre></td></tr></table></figure><p>后台 (detached) 模式创建 container： ^3c04af</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container run -d [image name]<br><br>// eg:<br>docker container run -d -p 80:80 nginx<br></code></pre></td></tr></table></figure><p>[[3. docker container run 背后发生了什么]]</p><h2 id="2-2-查看-container"><a href="#2-2-查看-container" class="headerlink" title="2.2 查看 container"></a>2.2 查看 container</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container ls<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/26/cU1SKVl5g2O7bPF.png"></p><p>可以使用旧版本指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container ps<br>docker ps<br></code></pre></td></tr></table></figure><p><code>ls</code> 与 <code>ps</code> 指令只能查看运行中的容器，如果想要查看所有容器，需要后缀参数 <code>-a</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker contianer ls -a<br></code></pre></td></tr></table></figure><p>列出所有的 container id（包含运行中和未运行的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container ls -qa<br></code></pre></td></tr></table></figure><h2 id="2-3-停止-container"><a href="#2-3-停止-container" class="headerlink" title="2.3 停止 container"></a>2.3 停止 container</h2><blockquote><p>windows 下必须手动停止，macos 在终端中结束后就自动停止</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container stop nginx<br>docker contianer stop [container id] // 使用 id 停止 docker（可以只用前两位）<br></code></pre></td></tr></table></figure><p>批量停止：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container stop $(docker container ps -qa)<br></code></pre></td></tr></table></figure><h2 id="2-4-重启-container"><a href="#2-4-重启-container" class="headerlink" title="2.4 重启 container"></a>2.4 重启 container</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container restart [docker id]<br></code></pre></td></tr></table></figure><h2 id="2-5-删除-container"><a href="#2-5-删除-container" class="headerlink" title="2.5 删除 container"></a>2.5 删除 container</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container rm [contianer id]<br></code></pre></td></tr></table></figure><p>批量删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container rm $(docker container ps -qa)<br></code></pre></td></tr></table></figure><p>强制删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container rm [container id] -f<br></code></pre></td></tr></table></figure><h2 id="2-6-在前台查看-container"><a href="#2-6-在前台查看-container" class="headerlink" title="2.6 在前台查看 container"></a>2.6 在前台查看 container</h2><p>使用 <a href="#%5E3c04af"><code>-d</code></a> 指令创建的 container 如果想要在前台查看，可以使用指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [contianer id]<br></code></pre></td></tr></table></figure><p>此时在前台查看 container 时如果在 UNIX 系统环境下，<code>ctrl+c</code> 会直接退出 container。</p><h2 id="2-7-查看-container-的日志"><a href="#2-7-查看-container-的日志" class="headerlink" title="2.7 查看 container 的日志"></a>2.7 查看 container 的日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container logs [container id]<br>docker container logs -f [container id] // 实时打印<br></code></pre></td></tr></table></figure><h2 id="2-8-交互式运行-container"><a href="#2-8-交互式运行-container" class="headerlink" title="2.8 交互式运行 container"></a>2.8 交互式运行 container</h2><p>在启动时进入交互式模式中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container run -it ubuntu sh // 会打开 Ubuntu 的 shell，并且可以交互<br></code></pre></td></tr></table></figure><p>以交互式的方式进入正在运行的 container 中【常用功能】：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it [container id] sh<br></code></pre></td></tr></table></figure><blockquote><p>如果以交互式模式启动一个 container，执行 <code>exit</code> 退出时会停掉整个容器，但是以交互式方式进入正在运行中的容器并退出时，并不会退出当前的容器。</p></blockquote><h2 id="2-9-查看-container-中的进程"><a href="#2-9-查看-container-中的进程" class="headerlink" title="2.9 查看 container 中的进程"></a>2.9 查看 container 中的进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container top [cotnainer id]<br></code></pre></td></tr></table></figure><h1 id="3-Image"><a href="#3-Image" class="headerlink" title="3. Image"></a>3. Image</h1><h2 id="3-1-获取镜像"><a href="#3-1-获取镜像" class="headerlink" title="3.1 获取镜像"></a>3.1 获取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image pull [registry] # 从 registry 拉取<br>docker image build from [Dockerfile] # 从 Dockerfile 构建<br>docker image load form [file] # 文件导入（离线）<br></code></pre></td></tr></table></figure><h2 id="3-2-查看已有的镜像"><a href="#3-2-查看已有的镜像" class="headerlink" title="3.2 查看已有的镜像"></a>3.2 查看已有的镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image ls<br></code></pre></td></tr></table></figure><h2 id="3-3-查看镜像详细信息"><a href="#3-3-查看镜像详细信息" class="headerlink" title="3.3 查看镜像详细信息"></a>3.3 查看镜像详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image inspect [image id]<br></code></pre></td></tr></table></figure><h2 id="3-4-删除镜像"><a href="#3-4-删除镜像" class="headerlink" title="3.4 删除镜像"></a>3.4 删除镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image rm [image id]<br></code></pre></td></tr></table></figure><blockquote><p>如果镜像被容器使用中，镜像是无法删除的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>常用指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简述Javascript的类型判断</title>
    <link href="/2022/12/50c59ea0ac7e.html"/>
    <url>/2022/12/50c59ea0ac7e.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h1><p>typeof 是 Javascript 的一个操作符，可以表示未经计算的操作数的类型。</p><p>如下是摘录自 MDN 的 <code>typeof</code> 可能输出的值的列表：</p><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Undefined">Undefined</a></td><td><code>&quot;undefined&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Null">Null</a></td><td><code>&quot;object&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean">Boolean</a></td><td><code>&quot;boolean&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Number">Number</a></td><td><code>&quot;number&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/BigInt">BigInt</a></td><td><code>&quot;bigint&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/String">String</a></td><td><code>&quot;string&quot;</code></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol">Symbol</a> (ECMAScript 2015 新增)</td><td><code>&quot;symbol&quot;</code></td></tr><tr><td>宿主对象（由 JS 环境提供）</td><td><em>取决于具体实现</em></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Function">Function</a> 对象 (按照 ECMA-262 规范实现 [[Call]])</td><td><code>&quot;function&quot;</code></td></tr><tr><td>其他任何对象</td><td><code>&quot;object&quot;</code></td></tr></tbody></table><p>使用 <code>typeof</code> 时要特别注意以下两个非预想的结果：</p><ul><li><code>typeof null</code> 输出为 “object”</li><li><code>typeof NaN</code> 输出为 “number” (NaN：Not-A-Number)</li></ul><p>此外 MDN 附加了以下 <code>typeof</code> 的诡异特性，在此进行摘录：</p><h3 id="null"><a href="#null" class="headerlink" title="null"></a><code>null</code></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// JavaScript 诞生以来便如此</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> === <span class="hljs-string">&#x27;object&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。（<a href="http://www.2ality.com/2013/10/typeof-null.html">参考来源</a>）</p><p>曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但<a href="http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null">被拒绝了</a>。该提案会导致 <code>typeof null === &#39;null&#39;</code>。</p><h3 id="使用-new-操作符"><a href="#使用-new-操作符" class="headerlink" title="使用 new 操作符"></a>使用 <code>new</code> 操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 除 Function 外的所有构造函数的类型都是 &#x27;object&#x27;</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;String&#x27;</span>);<br><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">typeof</span> str; <span class="hljs-comment">// 返回 &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> num; <span class="hljs-comment">// 返回 &#x27;object&#x27;</span><br><br><span class="hljs-keyword">var</span> func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>();<br><br><span class="hljs-keyword">typeof</span> func; <span class="hljs-comment">// 返回 &#x27;function&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="语法中的括号"><a href="#语法中的括号" class="headerlink" title="语法中的括号"></a>语法中的括号</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 括号有无将决定表达式的类型。</span><br><span class="hljs-keyword">var</span> iData = <span class="hljs-number">99</span>;<br><br><span class="hljs-keyword">typeof</span> iData + <span class="hljs-string">&#x27; Wisen&#x27;</span>; <span class="hljs-comment">// &#x27;number Wisen&#x27;</span><br><span class="hljs-keyword">typeof</span> (iData + <span class="hljs-string">&#x27; Wisen&#x27;</span>); <span class="hljs-comment">// &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>对正则表达式字面量的类型判断在某些浏览器中不符合标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> /s/ === <span class="hljs-string">&#x27;function&#x27;</span>; <span class="hljs-comment">// Chrome 1-12 , 不符合 ECMAScript 5.1</span><br><span class="hljs-keyword">typeof</span> /s/ === <span class="hljs-string">&#x27;object&#x27;</span>; <span class="hljs-comment">// Firefox 5+ , 符合 ECMAScript 5.1</span><br><br></code></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>在 ECMAScript 2015 之前，<code>typeof</code> 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，<code>typeof</code> 也能返回 <code>&#39;undefined&#39;</code>。使用 <code>typeof</code> 永远不会抛出错误。</p><p>但在加入了块级作用域的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">let</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const">const</a> 之后，在其被声明之前对块中的 <code>let</code> 和 <code>const</code> 变量使用 <code>typeof</code> 会抛出一个  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError">ReferenceError</a>。块作用域变量在块的头部处于“<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let">暂存死区</a>”，直至其被初始化，在这期间，访问变量将会引发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> undeclaredVariable === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><br><span class="hljs-keyword">typeof</span> newLetVariable; <span class="hljs-comment">// ReferenceError</span><br><span class="hljs-keyword">typeof</span> newConstVariable; <span class="hljs-comment">// ReferenceError</span><br><span class="hljs-keyword">typeof</span> newClass; <span class="hljs-comment">// ReferenceError</span><br><br><span class="hljs-keyword">let</span> newLetVariable;<br><span class="hljs-keyword">const</span> newConstVariable = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">newClass</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>当前所有的浏览器都暴露了一个类型为 <code>undefined</code> 的非标准宿主对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/all" title="Document 接口上的一个只读属性。返回一个 HTMLAllCollection，包含了页面上的所有元素。"><code>document.all</code></a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">all</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>尽管规范允许为非标准的外来对象自定义类型标签，但它要求这些类型标签与已有的不同。<code>document.all</code> 的类型标签为 <code>&#39;undefined&#39;</code> 的例子在 Web 领域中被归类为对原 ECMA JavaScript 标准的“故意侵犯”。</p><h1 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h1><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，换句话说，instanceof 可以帮助我们来判断一个对象是否是否继承与另一个对象。</p><h3 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h3><p>其实这里可以看一下 <code>instanceof</code> 运算符代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">instance_of</span>(<span class="hljs-params">L, R</span>) &#123;<span class="hljs-comment">//L 表示左表达式，R 表示右表达式</span><br> <span class="hljs-keyword">var</span> O = R.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<span class="hljs-comment">// 取 R 的显示原型</span><br> L = L.<span class="hljs-property">__proto__</span>;<span class="hljs-comment">// 取 L 的隐式原型</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <br>   <span class="hljs-keyword">if</span> (L === <span class="hljs-literal">null</span>) <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>   <span class="hljs-keyword">if</span> (O === L)<span class="hljs-comment">// 这里重点：当 O 严格等于 L 时，返回 true </span><br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>   L = L.<span class="hljs-property">__proto__</span>; <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>可以很容易发现，<code>instance_of</code> 方法取出了右边对象 R 的 <code>prototype</code> 属性，然后使用了 <code>while</code> 循环一层一层的去调出左边对象 L 的 <code>__proto__</code> 隐式原型，按照原型链的调用规则，如果 L 继承与 R ，那 L 在某一层的隐式原型一定与 R 的显示原型完全相等。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);<span class="hljs-comment">//false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);<span class="hljs-comment">//false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<span class="hljs-comment">//true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>);<span class="hljs-comment">//false</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);<span class="hljs-comment">//true </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<span class="hljs-comment">//true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);<span class="hljs-comment">//true </span><br></code></pre></td></tr></table></figure><p>上面第一组的解析我们很容易就能明白，因为一个对象本身的隐式原型与其显示原型不相等，那么肯定返回 <code>false</code>；第二组，Foo 函数构造于 <code>Function</code> 这是一个很标准的原型继承；而第三组似乎有些特殊，但是仔细看一下原型继承图我们就很容易看明白，对于 Object 来说 <code>Object.__proto__.proto__ === Object.prototype</code>，对于 Function 来说 <code>Function.__proto__ === Function.prototype</code>。</p><p><a href="!http://markdown.img.esunr.xyz/20191109222853.png"></a></p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>对于字面量而非对象的元素，不可以使用 instanceof 来判断类型，因为其本身并非是 Object，因此会出现如下的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span><br>num <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;string&quot;</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>)<br><span class="hljs-keyword">typeof</span> num <span class="hljs-comment">// &#x27;object&#x27;</span><br>num <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> str <span class="hljs-comment">// &#x27;object&#x27;</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但有趣的一点是，我们直接对比变量的隐式原型，其指向的正是这些内置对象的显式原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;string&quot;</span><br>str.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>按照 instance 的判断规则，可以判断出 <code>str instanceof String</code> 返回结果是 <code>true</code>，因此说明其底层对字面量元素进行了屏蔽，使其直接返回了 false 。因此对于字面量的 Number 或者 String，只能使用 typeof 来判断或者 <code>Object.prototype.toString()</code> 来判断。</p><h1 id="3-Object-prototype-toString"><a href="#3-Object-prototype-toString" class="headerlink" title="3.Object.prototype.toString()"></a>3.Object.prototype.toString()</h1><h3 id="被改写的-toString"><a href="#被改写的-toString" class="headerlink" title="被改写的 toString()"></a>被改写的 toString()</h3><p>由于 Object 对象的原型上挂载了一个 <code>toString()</code> 方法，因此根据原型链的调用规则，在 Javascript 中每个对象都可以调用 <code>toString()</code> 方法，其本身原意为返回一个表示该对象的字符串。</p><p>我们可以通过创建一个对象来调用该方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure><p>但是当我们调用 Number 类型或者 Array 类型时，其结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &#x27;123&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &#x27;1,2,3&#x27;</span><br></code></pre></td></tr></table></figure><p>这是由于在 <code>Number.prototype</code> 与 <code>Array.prototype</code> 上已经改写了 <code>toString()</code> 方法，<code>123.toString()</code> 执行的其实是 <code>Number.prototype.toString()</code> 而并非 <code>Object.prototype.toString()</code>。对于大部分的 Javascript 内建类型来说，都改写了 <code>toString()</code> 方法，用户自行创建的构造函数也可以通过在 <code>prototype</code> 上挂载 <code>toString()</code> 方法达到改写的目的。以下的表格列举了常见的类型对象调用 <code>toString()</code> 方法所输出的结果：</p><table><thead><tr><th>数据类型</th><th>例子</th><th>return</th></tr></thead><tbody><tr><td>字符串</td><td>“foo”.toString()</td><td>“foo”</td></tr><tr><td>数字</td><td>1.toString()</td><td>Uncaught SyntaxError: Invalid or unexpected token</td></tr><tr><td>布尔值</td><td>false.toString()</td><td>“false”</td></tr><tr><td>undefined</td><td>undefined.toString()</td><td>Uncaught TypeError: Cannot read property ‘toString’ of undefined</td></tr><tr><td>null</td><td>null.toString()</td><td>Uncaught TypeError: Cannot read property ‘toString’ of null</td></tr><tr><td>String</td><td>String.toString()</td><td>“function String() { [native code] }”</td></tr><tr><td>Number</td><td>Number.toString()</td><td>“function Number() { [native code] }”</td></tr><tr><td>Boolean</td><td>Boolean.toString()</td><td>“function Boolean() { [native code] }”</td></tr><tr><td>Array</td><td>Array.toString()</td><td>“function Array() { [native code] }”</td></tr><tr><td>Function</td><td>Function.toString()</td><td>“function Function() { [native code] }”</td></tr><tr><td>Date</td><td>Date.toString()</td><td>“function Date() { [native code] }”</td></tr><tr><td>RegExp</td><td>RegExp.toString()</td><td>“function RegExp() { [native code] }”</td></tr><tr><td>Error</td><td>Error.toString()</td><td>“function Error() { [native code] }”</td></tr><tr><td>Promise</td><td>Promise.toString()</td><td>“function Promise() { [native code] }”</td></tr><tr><td>Obejct</td><td>Object.toString()</td><td>“function Object() { [native code] }”</td></tr><tr><td>Math</td><td>Math.toString()</td><td>“[object Math]“</td></tr></tbody></table><p>那如果我们想强制让某一对象调用 <code>Object.prototype.toString()</code> 方法会发生什么呢？我们使用 <code>call</code> 来改写方法中的 <code>this</code> 可以达到这一效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(num)); <span class="hljs-comment">// &#x27;[Object Number]&#x27;</span><br></code></pre></td></tr></table></figure><p>可以发现通过借助 <code>Object.prototype.toString()</code> 我们可以获取到调用对象的类型，这一点非常有用，可以帮助我们接下来进行类型判断。</p><h3 id="内部原理-1"><a href="#内部原理-1" class="headerlink" title="内部原理"></a>内部原理</h3><p>在编写类型判断的方法之前，我们不妨来看一下 <code>Object.prototype.toString</code> 到底做了什么，在不同的 ES 版本中，该方法会有一定的区别：</p><p>ES5 环境下：</p><ul><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用ToObject(<strong>this</strong>)的结果.</li><li>让<em>class</em>成为<em>O</em>的内部属性[[Class]]的值.</li><li>返回三个字符串**”[object “,** <em>class</em>, 以及 **”]“**连接后的新字符串.</li></ul><p>ES6 环境下：</p><ul><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用ToObject(<strong>this</strong>)的结果.</li><li>如果<em>O</em>有[[NativeBrand]]内部属性,让<em>tag</em>成为表29中对应的值.</li><li>否则<ol><li>让<em>hasTag</em>成为调用<em>O</em>的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>hasTag</em>为<strong>false</strong>,则让<em>tag</em>为<code>&quot;Object&quot;</code>.</li><li>否则,<ol><li>让<em>tag</em>成为调用<em>O</em>的[[Get]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>tag</em>是一个abrupt completion,则让<em>tag</em>成为NormalCompletion(<code>&quot;???&quot;</code>).</li><li>让<em>tag</em>成为<em>tag</em>.[[value]].</li><li>如果Type(<em>tag</em>)不是字符串,则让<em>tag成为</em><code>&quot;???&quot;</code>.</li><li>如果<em>tag</em>的值为<code>&quot;Arguments&quot;</code>, <code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;JSON&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>,<code>或者&quot;String&quot;中的任一个,则让</code><em>tag</em>成为字符串<code>&quot;~&quot;和</code><em>tag</em>当前的值连接后的结果.</li></ol></li></ol></li><li>返回三个字符串”[object “, tag, and “]“连接后的新字符串.</li></ul><h3 id="封装一个类型判断的方法"><a href="#封装一个类型判断的方法" class="headerlink" title="封装一个类型判断的方法"></a>封装一个类型判断的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">type</span> (data)&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;type方法未传参&#x27;</span>);<br>  <span class="hljs-keyword">var</span> typeStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data);<br>  <span class="hljs-keyword">return</span> typeStr.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">toLowerCase</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript浅拷贝与深拷贝</title>
    <link href="/2022/12/f7b88c5a43cb.html"/>
    <url>/2022/12/f7b88c5a43cb.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1. 回顾"></a>1. 回顾</h1><p>JavaScript中有6种数据类型：数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><p>对于引用类型来说其存放于堆内存，当其被做一个 LSH 引用时，其只是引用了堆内存的地址，而并非跟值类型的数据一样开辟一块新内存，所以如果想要拷贝引用类型的数据往往比较繁琐，数组、函数、对象、Map 都属于引用类型。</p><h1 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2. 浅拷贝"></a>2. 浅拷贝</h1><p>浅拷贝相当于仅对最外层元素做了拷贝，假如对象中的某个值仍是一个引用类型的值，那么嵌套的这个引用类型将不会被拷贝。</p><p>数组的浅拷贝可以使用 <code>slice()</code> 来实现，而对象的浅拷贝可以通过遍历对象实现，也可以通过 <code>Object.assign</code> 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">simpleCopy</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-title function_">slice</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3. 深拷贝"></a>3. 深拷贝</h1><p>为了弥补浅拷贝的缺点，那么我们就需要对元素进行深拷贝，最简单粗暴的方式就是使用 <code>JSON.stringify()</code> 这个方式来将对象转换为字符串，再通过 <code>JSON.parse()</code> 来转换。但是这样的话 <code>undefined</code> 就会被忽略掉，同时原型链也会丢失，举一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">brak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;wangwangwang&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">d</span>: <span class="hljs-number">3</span><br>  &#125;,<br>  <span class="hljs-attr">e</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">f</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">g</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;huahua&quot;</span>)<br>&#125;;<br><br><span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newObj: &quot;</span>, newObj);<br>newObj.<span class="hljs-property">g</span>.<span class="hljs-title function_">brak</span>();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">newObj</span>:  &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">f</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">g</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;huahua&#x27;</span> &#125; &#125;<br><span class="hljs-title class_">TypeError</span>: newObj.<span class="hljs-property">g</span>.<span class="hljs-property">brak</span> is not a <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以使用递归来解决，只要判断每一个值如果是 <code>Object</code> 类型，就对其递归进行深拷贝。如下的深拷贝即可实现对原型链方法的拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">let</span> newObj;<br>  <span class="hljs-comment">// 获取该对象的类型,如 Function、Array 等</span><br>  <span class="hljs-keyword">let</span> type = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;type: &#x27;</span>, type);<br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;Array&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果深拷贝的对象是一个数组，初始化这个数组</span><br>    newObj = [];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;Object&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果深拷贝的对象是一个普通对象</span><br>    newObj = &#123;&#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果被拷贝的对象既不是 Array 也不是 Object，那么就说明其可能是 Function、RegExp、Date 这种特殊类型，直接返回原值</span><br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj[key] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;<br>      <span class="hljs-comment">// 如果当前 key 的值是一个 Object 类型，就对该对象进行递归调用</span><br>      newObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      newObj[key] = obj[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux指令备忘录</title>
    <link href="/2022/12/28029806aaec.html"/>
    <url>/2022/12/28029806aaec.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-系统相关"><a href="#1-系统相关" class="headerlink" title="1. 系统相关"></a>1. 系统相关</h1><h3 id="关机与重启"><a href="#关机与重启" class="headerlink" title="关机与重启"></a>关机与重启</h3><p>关机指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">shutdown <br> [-t] 在改变到其它runlevel之前﹐告诉init多久以后关机。<br> [-r] 重启计算器。<br> [-k] 并不真正关机﹐只是送警告信号给每位登录者〔login〕。<br> [-h] 关机后关闭电源〔halt〕。<br> [-n] 不用init﹐而是自己来关机。不鼓励使用这个选项﹐而且该选项所产生的后果往往不总是你所预期得到的。<br> [-c] cancel current process取消目前正在执行的关机程序。所以这个选项当然没有时间参数﹐但是可以输入一个用来解释的讯<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">halt <br>halt = shutdown -h<br>[-n] 防止<span class="hljs-built_in">sync</span>系统调用﹐它用在用fsck修补根分区之后﹐以阻止内核用老版本的超级块〔superblock〕覆盖修补过的超级块。<br>[-w] 并不是真正的重启或关机﹐只是写wtmp〔/var/log/wtmp〕纪录。<br>[-d] 不写wtmp纪录〔已包含在选项[-n]中〕。<br>[-f] 没有调用shutdown而强制关机或重启。<br>[-i] 关机〔或重启〕前﹐关掉所有的网络接口。<br>[-p] 该选项为缺省选项。就是关机时调用poweroff。<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">init</span><br><span class="hljs-keyword">init</span> <span class="hljs-number">0</span>为关机﹐<span class="hljs-keyword">init</span> <span class="hljs-number">1</span>为重启<br></code></pre></td></tr></table></figure><p>重启指令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure><h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -ntulp | grep 3306 //查看所有3306端口使用情况<br></code></pre></td></tr></table></figure><h3 id="删除进程"><a href="#删除进程" class="headerlink" title="删除进程"></a>删除进程</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> -9 pid<br></code></pre></td></tr></table></figure><h1 id="2-账号相关"><a href="#2-账号相关" class="headerlink" title="2. 账号相关"></a>2. 账号相关</h1><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo useradd [Options] UserName<br></code></pre></td></tr></table></figure><p>其中各选项含义如下：</p><p>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p><p>为用户添加密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo passwd UserName<br></code></pre></td></tr></table></figure><p>通常 <code>useradd</code> 指令创建一个新用户需要对新用户进行各种初始化设置，如果不想手动设置，可以使用 <code>adduser</code> 指令快速添加一个新用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo adduser UserName<br></code></pre></td></tr></table></figure><h3 id="用户组群"><a href="#用户组群" class="headerlink" title="用户组群"></a>用户组群</h3><p>创建组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo groupadd GroupName <br></code></pre></td></tr></table></figure><p>将用户加入组（三选一）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo usermod -G GroupName UserName  <span class="hljs-comment"># 这个会把用户从其他组中去掉</span><br>sudo usermod -a GroupName UserName<br>sudo gpasswd -a UserName GroupName<br></code></pre></td></tr></table></figure><p>查看当前用户所在组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">groups</span><br>&gt; root<br></code></pre></td></tr></table></figure><p>查看固定用户的权限组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">groups</span> root zpangxie<br>&gt; root[用户名]: root[用户组]<br>&gt; zpangxie: zpangxie<br></code></pre></td></tr></table></figure><p>查看组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /etc/group<br><br>在/etc/group 中的每条记录分四个字段：<br>第一字段：用户组名称；<br>第二字段：用户组密码；<br>第三字段：GID<br>第四字段：用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名；<br></code></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>切换用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su [username]<br></code></pre></td></tr></table></figure><h3 id="使用-root-用户"><a href="#使用-root-用户" class="headerlink" title="使用 root 用户"></a>使用 root 用户</h3><p>创建并登录root用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo passwd root <span class="hljs-comment"># 创建 root 用户</span><br>su  <span class="hljs-comment"># 登录 root 用户</span><br></code></pre></td></tr></table></figure><h1 id="3-权限相关"><a href="#3-权限相关" class="headerlink" title="3. 权限相关"></a>3. 权限相关</h1><h3 id="权限基本知识"><a href="#权限基本知识" class="headerlink" title="权限基本知识"></a>权限基本知识</h3><p>权限示例：<code>-rw-rw-r--</code></p><p><strong>权限一共有10位数其中：</strong></p><ul><li><p>最前面那个 <code>-</code> 代表的是类型：<code>-</code> 代表文件，<code>d</code> 代表文件夹</p></li><li><p>中间那三个 <code>rw-</code> 代表的是所有者（user）</p></li><li><p>然后那三个 <code>rw-</code> 代表的是组群（group）</p></li><li><p>最后那三个 <code>r--</code> 代表的是其他人（other）</p></li></ul><p><strong>rwx 的含义：</strong></p><p>r 表示文件可以被读（read），w 表示文件可以被写（write），x 表示文件可以被执行（如果它是程序的话）。</p><p><strong>用数字代替rwx：</strong></p><ul><li><p>r &#x3D; 4</p></li><li><p>w &#x3D; 2</p></li><li><p>x &#x3D; 1</p></li></ul><p><strong>Tips：</strong></p><ul><li><p>如果递归删除一个文件夹，文件夹内有当前用户没有权限的文件的话，会跳过删除，只删除有权限的文件。</p></li><li><p>如果一个文件是只读属性，用户去强制修改后原来的文件会被命名为 <code>FileName~</code> 的形式保留下来。</p></li></ul><h3 id="权限的查看"><a href="#权限的查看" class="headerlink" title="权限的查看"></a>权限的查看</h3><p>查看文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> -l FileName  <span class="hljs-comment"># 查看指定文件权限</span><br><span class="hljs-built_in">ls</span> -l <span class="hljs-comment"># 查看当前文件夹所有文件的权限详情，如果有子文件是文件夹，则列出文件夹权限详情</span><br></code></pre></td></tr></table></figure><p>查看文件夹权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> -ld FolderName   <span class="hljs-comment"># 查看指定文件夹权限</span><br><span class="hljs-built_in">ls</span> -ld <span class="hljs-comment"># 查看当前文件夹权限</span><br></code></pre></td></tr></table></figure><p>权限输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">total 0 [文件列表总大小]<br>-rw-rw-r--[权限详情] 1[硬连接个数] zpangxie[创建人] zpangxie[归属组] 17[文件大小] Dec 5 17:34 <span class="hljs-built_in">test</span>[文件名]<br></code></pre></td></tr></table></figure><blockquote><p>文件被创建后，默认的权限为 -rw-rw-r– 也就是 664</p></blockquote><h3 id="权限的修改"><a href="#权限的修改" class="headerlink" title="权限的修改"></a>权限的修改</h3><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 FileName<br></code></pre></td></tr></table></figure><p>递归修改文件权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> -R <span class="hljs-number">777</span> FolderName<br></code></pre></td></tr></table></figure><p>如果递归修改权限的文件夹中有当前执行指令用户没有权限的文件，那么就会出现提醒拒绝修改，只修改用户有权限的文件。</p><p>修改文件的归属组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chown</span> [-R] 用户名:群组名 文件或目录<br></code></pre></td></tr></table></figure><h1 id="4-文件相关"><a href="#4-文件相关" class="headerlink" title="4. 文件相关"></a>4. 文件相关</h1><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> [Option] SorceFile TargetFile<br><span class="hljs-built_in">cp</span> -r FolderName TargetFolder <span class="hljs-comment"># 复制文件夹，移动文件夹不受制于权限，文件的权限信息会一并被复制</span><br><span class="hljs-built_in">cp</span> -r FolderName1/* FolderName2<span class="hljs-comment"># 将 FolderName1 下的文件全部覆盖到 FolderName2 下，覆盖文件不会有提示</span><br><span class="hljs-built_in">cp</span> -r -i FloderName1 FolderName2 <span class="hljs-comment"># 将 FolderName1 下的文件全部覆盖到 FolderName2 下，覆盖文件会有提示</span><br></code></pre></td></tr></table></figure><blockquote><p>文件复制默认覆盖，但是文件夹递归复制不会覆盖文件</p></blockquote><p>参数说明：</p><p>-a:是指archive的意思，也说是指复制所有的目录</p><p>-d:若源文件为连接文件(link file)，则复制连接文件属性而非文件本身</p><p>-f:强制(force)，若有重复或其它疑问时，不会询问用户，而强制复制</p><p>-i:若目标文件(destination)已存在，在覆盖时会先询问是否真的操作</p><p>-l:建立硬连接(hard link)的连接文件，而非复制文件本身</p><p>-p:与文件的属性一起复制，而非使用默认属性</p><p>-r:递归复制，用于目录的复制操作</p><p>-s:复制成符号连接文件(symbolic link)，即“快捷方式”文件</p><p>-u:若目标文件比源文件旧，更新目标文件 </p><h3 id="压缩文件处理"><a href="#压缩文件处理" class="headerlink" title="压缩文件处理"></a>压缩文件处理</h3><p><strong><code>.tar</code> 文件</strong></p><p>压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zcvf distFilePath（生成压缩包的目录） originFilePath（要压缩的文件目录）<br></code></pre></td></tr></table></figure><blockquote><p>示例：tar -zcvf &#x2F;home&#x2F;xahot.tar.gz &#x2F;xahot</p></blockquote><p>解压：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zcxf targetFile<br></code></pre></td></tr></table></figure><p><strong><code>.zip</code> 文件</strong></p><p>压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zip -r distFilePath originFilePath/* -r <span class="hljs-comment"># r表示递归</span><br></code></pre></td></tr></table></figure><blockquote><p>示例：zip -r .&#x2F;xahot.zip .&#x2F;* -r</p></blockquote><p>linux zip命令参数列表：</p><ul><li><p><code>-a</code> 将文件转成ASCII模式</p></li><li><p><code>-F</code> 尝试修复损坏的压缩文件</p></li><li><p><code>-h</code> 显示帮助界面</p></li><li><p><code>-m</code> 将文件压缩之后，删除源文件</p></li><li><p><code>-n</code> 特定字符串 不压缩具有特定字尾字符串的文件</p></li><li><p><code>-o</code> 将压缩文件内的所有文件的最新变动时间设为压缩时候的时间</p></li><li><p><code>-q</code> 安静模式，在压缩的时候不显示指令的执行过程</p></li><li><p><code>-r</code> 将指定的目录下的所有子目录以及文件一起处理</p></li><li><p><code>-S</code> 包含系统文件和隐含文件（S是大写）</p></li><li><p><code>-t</code> 日期 把压缩文件的最后修改日期设为指定的日期，日期格式为mmddyyyy</p></li></ul><p>解压：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">unzip tragetFile <span class="hljs-comment"># 解压到当前目录</span><br></code></pre></td></tr></table></figure><h1 id="5-应用相关"><a href="#5-应用相关" class="headerlink" title="5. 应用相关"></a>5. 应用相关</h1><h3 id="查找应用"><a href="#查找应用" class="headerlink" title="查找应用"></a>查找应用</h3><p>通过以下指令可以查找到安装过的应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg --get-selections | grep appName<br></code></pre></td></tr></table></figure><p>通过以下指令查看安装的应用的详情：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg -l appName<br></code></pre></td></tr></table></figure><p>通过以下指令查找软件位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg -L appName<br></code></pre></td></tr></table></figure><h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p><code>apt-get purge / apt-get --purge remove</code></p><p>删除已安装包（不保留配置文件）。</p><p>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件</p><p><code>apt-get autoremove</code></p><p>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p><p><code>apt-get remove</code></p><p>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p><p><code>apt-get autoclean</code></p><p>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;中，apt-get autoclean 只会删除 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 已经过期的deb。</p><p><code>apt-get clean</code></p><p>使用 apt-get clean 会将 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 的 所有 deb 删掉，可以理解为 rm &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;*.deb。</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>当在源码安装的过程中如果在生成内容时用 <code>prefix</code> 设置了源码安装应用的位置，那么安装的应用携带有 bin 文件，是无法自动与系统做关联的，我们就无法在 bash 中直接使用它们，与 Windows 相似的，我们需要添加系统环境变量中的 PATH 才能连接到应用的 bin 文件，这时如果直接在命令行中使用 <code>export</code> 设置 PATH 的话只是临时的，如果想要永久产生影响就还是需要去修改 <code>/etc/.profile</code> 文件，这是在系统每次启动时会自动执行的文件，我们在这里设置 PATH 会让系统在每次开机时都应用这些 PATH，与其相类似的文件还有以下几个：</p><ol><li><p><strong>&#x2F;etc&#x2F;profile：</strong> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置。</p></li><li><p><strong>&#x2F;etc&#x2F;bashrc:</strong> 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</p></li><li><p><strong>~&#x2F;.bash_profile:</strong> 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。</p></li><li><p><strong>~&#x2F;.bashrc:</strong> 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p></li><li><p><strong>~&#x2F;.bash_logout:</strong> 当每次退出系统(退出bash shell)时,执行该文件. 另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承 &#x2F;etc&#x2F;profile中的变量,他们是”父子”关系。</p></li><li><p><strong>~&#x2F;.bash_profile:</strong> 是交互式、login 方式进入 bash 运行的~&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/profile<br><br><span class="hljs-comment">###### /etc/profile</span><br><span class="hljs-comment"># $PATH 表示已经设置的环境变量</span><br><span class="hljs-built_in">export</span> PATH=xxx/xxx/bin:<span class="hljs-variable">$PATH</span> <br><span class="hljs-comment">######</span><br></code></pre></td></tr></table></figure><p>保存后再运行该文件让其生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>输出环境变量检查是否设置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用requestAnimationFrame平滑无卡顿插入100000条数据</title>
    <link href="/2022/12/b4da60d67a0b.html"/>
    <url>/2022/12/b4da60d67a0b.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>网页回流与重绘有时可能会比 JS 的执行消耗更长的时间，比如插入十万条数据，这可能是一个伪需求，但是也是一个值得思考的命题。接下来我们的例子中的 html 都用如下的结构，点击页面按钮后，将 100000 个 <code>li</code> 插入到 <code>ul</code> 中去：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;pushLi()&quot;</span>&gt;</span>添加数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们先来看一下直接暴力插入 100000 条数据的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushLi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">valueOf</span>()<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">100000</span><br>  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>    li.<span class="hljs-property">innerText</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * count<br>    ul.<span class="hljs-title function_">appendChild</span>(li)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">valueOf</span>() - startTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>点击按钮，页面大概消耗了 5s 的时间才把内容渲染出来，但是我们看控制台打印出的时间差只有 1s 左右。</p><p><img src="https://i.loli.net/2019/12/02/a6gsRlMCG5jmk9p.png"></p><p>这是因为浏览器本身存在优化机制，如果没进行一次 <code>appendChild</code> 操作就渲染一次页面，那么就要渲染十万次页面，这样是非常消耗性能的。所以浏览器就会将渲染任务缓存到队列中，在一定的范围内将页面的所有操作合并为一个渲染操作。但是十万条数据仍是一个庞大的数据，因此就会出现 js 已经计算完成，但是渲染仍为完成的情况，此时页面会卡住不动。</p><h1 id="2-初级优化"><a href="#2-初级优化" class="headerlink" title="2. 初级优化"></a>2. 初级优化</h1><p><code>document.createDocumentFragment()</code> 可以创建一个片段，这个片段并没有插入的 DOM 结构中，因此就省去了 DOM 查询的步骤，我们将创建的 <code>li</code> 没次都插入到 <code>fragment</code> 中，而不是每次都插入页面的 DOM 中，最后再将 fragment 插入到页面的 <code>ul</code> 中，这样的话就能一定程度提升 js 运算的性能，从而优化整体效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushLi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">valueOf</span>()<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">100000</span><br>  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>)<br>  <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>    li.<span class="hljs-property">innerText</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * count<br>    fragment.<span class="hljs-title function_">appendChild</span>(li)<br>  &#125;<br>  ul.<span class="hljs-title function_">appendChild</span>(fragment)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">valueOf</span>() - startTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在控制台中查看打印的时间差，可以发现 JS 的执行速度提升了一倍：</p><p><img src="https://i.loli.net/2019/12/02/m9awpHG2cKPbBdf.png"></p><p>那么渲染速度是否会因此提升呢？很遗憾并不，渲染仍在消耗相同的时间，因为我们最终插入页面的数据仍然是十万条，对于浏览器页面来说，仍是一次渲染十万条数据。</p><h1 id="3-节流插入"><a href="#3-节流插入" class="headerlink" title="3. 节流插入"></a>3. 节流插入</h1><p>我们换一种思路，既然一次插入 100000 条数据会给浏览器造成巨大的压力，那么每次只要少渲染一点不久可以了吗。比如说我们在 100ms 渲染 100 条数据，十万条数据分 1000 次插入，也就是耗时 1000 * 100s，虽然耗时相比之下长了，但是页面不卡顿了，用户点击之后马上就可以看到数据，同时数据也在不断增长，直到十万条数据都出来，浏览器便可以停止渲染，这比让用户盯着屏幕卡顿 10 秒的效果好的多。</p><p>于是我们来优化一下写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushLi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>)<br>  <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span><br>  <span class="hljs-keyword">const</span> once = <span class="hljs-number">100</span><br>  <span class="hljs-keyword">const</span> loopCount = total / once<br>  <span class="hljs-keyword">let</span> countOfRender = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 每 100 毫秒添加 100 条 li</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; once; i++) &#123;<br>        <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>)<br>        li.<span class="hljs-property">innerText</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total<br>        fragment.<span class="hljs-title function_">appendChild</span>(li)<br>      &#125;<br>      ul.<span class="hljs-title function_">appendChild</span>(fragment)<br>      <span class="hljs-comment">// 当前渲染到第几次</span><br>      countOfRender += <span class="hljs-number">1</span><br>      <span class="hljs-comment">// 如果没有渲染完成就递归再渲染一次</span><br>      <span class="hljs-keyword">if</span> (countOfRender &lt; loopCount) &#123;<br>        <span class="hljs-title function_">add</span>()<br>      &#125;<br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125;<br>  <span class="hljs-title function_">add</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/02/1tZNFeqbydKLRV2.gif"></p><p>这样页面就不会卡顿了，但是这样的渲染并没有用到浏览器的性能极限。想想假如我们要想提高渲染效率，要从哪里下手呢？就是去将每次渲染的间隔时间尽量最小化，我们上面的例子使用了 100ms 这其实是不够极限的，只要时间段够短并且浏览器能渲染得过来，那就是合理的。那么最小到哪个阈值呢，我们都知道大部分屏幕的刷新率是 60hz 也就是每秒刷新 60 次，对于我们页面来说极限就是每秒渲染 60 次。我们用 100&#x2F;60 得出每间隔 16ms 刷新一次是浏览器显示的极限，我们可以将 <code>setTimeout</code> 的时间间隔设置为 16 即可。</p><p>但是当我得意的将 <code>setTimeout</code> 的延时设置为 16ms 时突然发现事情并不对… …</p><p><img src="https://i.loli.net/2019/12/02/2P7WbHKjuGx4MUd.png"></p><p>发现改为了 16ms 之后，按理说，数据增长应该是平滑的，然而改了之后还是跟之前一样数据是一卡一卡的。emmmm，我知道 setTimeout 有最小值，查了一下最小值为 4ms，这也不对啊。上 MDN 查阅了一下发现了一篇文章 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#%E5%AE%9E%E9%99%85%E5%BB%B6%E6%97%B6%E6%AF%94%E8%AE%BE%E5%AE%9A%E5%80%BC%E6%9B%B4%E4%B9%85%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4">实际延时比设定值更久的原因：最小延迟时间</a>。</p><p>MDN 告诉我们，多次嵌套 <code>setTimeout</code> 可能会导致计时器的时间推迟。我们添加一个记录值，来记录上次渲染结束到本次渲染结束的时间间隔，也就是实际 setTimeout 延迟的时间，发现果然随着嵌套的深度，延迟执行的时间越来越长：</p><p><img src="https://i.loli.net/2019/12/03/uOM1wCa4cFpsg9b.png" alt="刚开始的耗时"></p><p><img src="https://i.loli.net/2019/12/03/iRrIjK9nA6Sadyv.png" alt="当嵌套越来越深时"></p><p>所以为了避免嵌套，那么我们就只能利用异步编程，来逐个循环执行定时器了，改写一下我们之前写好的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushLi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>)<br>  <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span><br>  <span class="hljs-keyword">const</span> once = <span class="hljs-number">20</span><br>  <span class="hljs-keyword">const</span> loopCount = total / once<br>  <span class="hljs-keyword">let</span> countOfRender = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 执行定时器的方法改写为一个 promise </span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; once; i++) &#123;<br>          <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>)<br>          li.<span class="hljs-property">innerText</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total<br>          fragment.<span class="hljs-title function_">appendChild</span>(li)<br>        &#125;<br>        ul.<span class="hljs-title function_">appendChild</span>(fragment)<br>        countOfRender += <span class="hljs-number">1</span><br>        <span class="hljs-title function_">resolve</span>()<br>      &#125;, <span class="hljs-number">16</span>);<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 专门用来执行循环的函数</span><br>  <span class="hljs-comment">// 当执行完一个定时器后再开启一个新的定时器，所以定时器之间不存在嵌套</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">add</span>()<br>    <span class="hljs-keyword">if</span> (countOfRender &lt; loopCount) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countOfRender);<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">loop</span>()<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">loop</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这下就好多了，当渲染到第 287 次的时候，仍能保持时间间隔为 34ms。可以看出就算定时器没有嵌套，也会出现数据越多定时器的耗时间隔越长的情况。我分析可能会是这两个原因：要么是由于时间间隔过短，渲染没有跟上速度，导致了执行被阻塞，越来越往后推；要么是页面中还有定时器影响着新定时器的执行速度。</p><p><img src="https://i.loli.net/2019/12/03/aiKUjVTt5uGYDJ7.png"></p><h1 id="4-requestAnimationFrame"><a href="#4-requestAnimationFrame" class="headerlink" title="4. requestAnimationFrame"></a>4. requestAnimationFrame</h1><p>终于到了我们的主客 <code>requestAnimationFrame</code>，其实原理跟我们上面讲的几乎是一摸一样，但是 <code>requestAnimationFrame</code> 提供了一种更优雅的方式，以及更好的优化性能，我们将上面的定时器改为 <code>requestAnimationFrame</code>，方法就变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushLi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span><br>  <span class="hljs-keyword">const</span> once = <span class="hljs-number">20</span><br>  <span class="hljs-keyword">const</span> loopCount = total / once<br>  <span class="hljs-keyword">let</span> countOfRender = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; once; i++) &#123;<br>      <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>)<br>      li.<span class="hljs-property">innerText</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total<br>      fragment.<span class="hljs-title function_">appendChild</span>(li)<br>    &#125;<br>    ul.<span class="hljs-title function_">appendChild</span>(fragment)<br>    countOfRender += <span class="hljs-number">1</span><br>    <span class="hljs-title function_">loop</span>()<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (countOfRender &lt; loopCount) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(add)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">loop</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这感觉，丝滑般流畅：</p><p><img src="https://i.loli.net/2019/12/03/K8YNJ9ZkdtsObSG.gif"></p><p>但是，使用 <code>requestAnimationFrame</code> 也会出现后期时间间隔边长，也就是帧率变低的情况，也许就是因为页面数据过多造成性能的上不足导致的，但是相比与纯定时器，效果会更好一丢丢：</p><p><img src="https://i.loli.net/2019/12/03/puX2Uh6t8nHbIP7.png" alt="requestAnimationFrame 在 1100 次渲染时的耗时间隔"></p><p><img src="https://i.loli.net/2019/12/03/iq3aeGwyQpcE6lf.png" alt="setTimeout 在 1100 次渲染时的耗时间隔"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3选择器的 nth-child 与 nth-of-type</title>
    <link href="/2022/12/56ebbc1dcaeb.html"/>
    <url>/2022/12/56ebbc1dcaeb.html</url>
    
    <content type="html"><![CDATA[<h1 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child"></a>nth-child</h1><blockquote><p>官方解释：<code>p:nth-child(2)</code> 规定属于其父元素的第二个子元素的每个 p 的背景色</p></blockquote><p>最难让我头大的就是这个 <code>nth-child</code> 本身不难理解，就是选择对应父级的第 n 个节点元素，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 基础样式，分离每个 .wrapper 下的子元素 */</span><br><span class="hljs-selector-class">.wrapper</span>&gt;* &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid pink;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>i&#x27;m p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>i&#x27;m p too<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>i&#x27;m div<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/EnRM6Q5wbmPZUxN.png"></p><p>但是恶心就恶心在，在这里使用的伪类是后缀与一个空选择器上，所以就直接表示为父元素的第二个子元素，那么如果我们为其前面加上一个 <code>li</code>，那就变成了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/7IGbWzC2lrFAt8y.png"></p><p>经过一翻思想斗争，终于悟出了这里的语法解释意思为：选择 <code>.wrapper</code> 下的每个 <code>li</code> 元素，然后看这个 <code>li</code> 元素是否是其父级元素的第二个子元素，如果是就应用样式，如果不是就不应用样式。</p><p>我们要理解普通选择器是向下查找，每次添加条件，而伪类是用来过滤选择到的元素。</p><h1 id="last-child"><a href="#last-child" class="headerlink" title="last-child"></a>last-child</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/OUkoEIPAaRQ4tKY.png"></p><h1 id="first-child"><a href="#first-child" class="headerlink" title="first-child"></a>first-child</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/76jk8dcLsuUGbtE.png"></p><h1 id="nth-of-type"><a href="#nth-of-type" class="headerlink" title="nth-of-type"></a>nth-of-type</h1><blockquote><p>官方解释：<code>p:nth-of-type(2)</code> 选择每个p元素是其父级的第二个p元素</p></blockquote><p>我们按照刚才的思路去理解这个选择器，其流程为：选择 <code>.wrapper</code> 下的所有 <code>li</code> 元素，如果其在当前的同类型的兄弟节点中排第二个，那么就应用样式，否则不应用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/UfrIEFSnvN2Vt4y.png"></p><p>但是如果前面不加 <code>li</code>，而应用于 <code>.wrapper</code> 下的每个元素，那么就会变成：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> :nth-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>(<span class="hljs-number">2</span>) &#123;<br>  background-color: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/N2QHjxTtnbIXf9i.png"></p><p>这个是因为没有规定子级的过滤元素，那么在匹配到每个新的标签类型时，都会验证其在兄弟节点相同的标签类型下，其是否是第2个，如果是就应用样式，如果不是就不应用样式</p><h1 id="权重问题"><a href="#权重问题" class="headerlink" title="权重问题"></a>权重问题</h1><p>CSS 的伪类选择器权重与 class 选择器权重是同等级的，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/lSwPCH1p6BkLaxQ.png"></p><p>同等级下，伪类选择器的效果覆盖了 class 选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/9TGyMjkSzHsgulq.png"></p><p>调换位置后，class选择器覆盖了伪类选择器的效果</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用操作整理</title>
    <link href="/2022/11/ebd6750c1b7f.html"/>
    <url>/2022/11/ebd6750c1b7f.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Git-基本原理"><a href="#1-Git-基本原理" class="headerlink" title="1. Git 基本原理"></a>1. Git 基本原理</h1><ul><li>工作区：我们能看到的，用来写代码的区域</li><li>暂存区：临时存储用的</li><li>历史区：生成历史版本</li></ul><p><img src="http://img.cdn.esunr.xyz/markdown/20191118231730.png" alt="Git基本工作流程"></p><h1 id="2-基础指令"><a href="#2-基础指令" class="headerlink" title="2. 基础指令"></a>2. 基础指令</h1><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>查看配置信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config -l           <span class="hljs-comment"># 查看配置信息</span><br>git config --global -l  <span class="hljs-comment"># 查看全局配置</span><br>git config --<span class="hljs-built_in">local</span>  -l  <span class="hljs-comment"># 查看当前项目配置</span><br></code></pre></td></tr></table></figure><p>设置配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&#x27;username&#x27;</span><br>git config --global user.email <span class="hljs-string">&#x27;email&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="提交到暂存区"><a href="#提交到暂存区" class="headerlink" title="提交到暂存区"></a>提交到暂存区</h2><p>在本地编写完成代码后，把一些内容提交到暂存区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git add xxx   <span class="hljs-comment"># 把某个文件提交到暂存区</span><br>git add .     <span class="hljs-comment"># 把当前仓库中的所有最新修改的文件都提交到暂存区</span><br>git add -A    <span class="hljs-comment"># 同上</span><br></code></pre></td></tr></table></figure><h2 id="查看当前文件状态"><a href="#查看当前文件状态" class="headerlink" title="查看当前文件状态"></a>查看当前文件状态</h2><p>红色代表在工作区，绿色代表在暂存区，看不见东西证明所有修改信息都已提交到历史区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git status <br></code></pre></td></tr></table></figure><p><img src="http://img.cdn.esunr.xyz/markdown/20191118233413.png" alt="演示示例"></p><h2 id="提交到历史区"><a href="#提交到历史区" class="headerlink" title="提交到历史区"></a>提交到历史区</h2><p>只能将暂存区中的代码提交到历史区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git commit -m <span class="hljs-string">&#x27;描述信息&#x27;</span><br></code></pre></td></tr></table></figure><p>查看历史信息：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git <span class="hljs-built_in">log</span>         <span class="hljs-meta"># 查看历史版本信息</span><br>git reflog      <span class="hljs-meta"># 查看包含回滚信息的历史版本信息</span><br>git <span class="hljs-built_in">log</span> --<span class="hljs-keyword">graph</span> <span class="hljs-meta"># 以时间线的形式查看分支信息</span><br></code></pre></td></tr></table></figure><p>从工作区提交到暂存区、从暂存区提交到历史区都是把内容复制一份传过去，文本域中仍存在这些信息。</p><blockquote><p>在 vscode 中，更改后的代码在提交时可以自动进行暂存操作（add），无需再手动暂存。</p></blockquote><h1 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3. 远程仓库"></a>3. 远程仓库</h1><h2 id="远程源"><a href="#远程源" class="headerlink" title="远程源"></a>远程源</h2><p>查看当前仓库远程源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote -v<br></code></pre></td></tr></table></figure><p>添加&#x2F;删除远程源:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add origin <span class="hljs-string">&#x27;Git Origin&#x27;</span>   <br>git remote remove origin <span class="hljs-string">&#x27;Git Origin&#x27;</span>   <br></code></pre></td></tr></table></figure><h2 id="拉取提交到远程源"><a href="#拉取提交到远程源" class="headerlink" title="拉取提交到远程源"></a>拉取提交到远程源</h2><p>拉取远程源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git pull origin master<br></code></pre></td></tr></table></figure><p>提交远程源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push origin master<br></code></pre></td></tr></table></figure><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>Clone 可以简化拉取远程项目的步骤，与 <code>add remote origin</code> 并 <code>git pull</code> 不同的是，Clone 拉取的是整个项目的所有分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> <span class="hljs-string">&#x27;Git Origin&#x27;</span> <br></code></pre></td></tr></table></figure><h2 id="https-免密码同步"><a href="#https-免密码同步" class="headerlink" title="https 免密码同步"></a>https 免密码同步</h2><p>在添加 git remote 地址的时候，如果使用的是 https，则需要每次提交同步代码的时候都输入用户名与密码，为了免去用户名与密码的输入我们可以修改 <code>.git/config</code> 文件下的配置，添加用户名与密码：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">## config<br><br>[remote &quot;origin&quot;]<br><span class="hljs-deletion">-      url = https://github.com/UserName/YourProject.git</span><br><span class="hljs-addition">+      url = https://username:password@github.com/UserName/YourProject.git</span><br></code></pre></td></tr></table></figure><h1 id="4-内容处理"><a href="#4-内容处理" class="headerlink" title="4. 内容处理"></a>4. 内容处理</h1><h2 id="丢弃更改"><a href="#丢弃更改" class="headerlink" title="丢弃更改"></a>丢弃更改</h2><p>当文件进行变更后，且尚未进入暂存区时，使用 <code>chekcout --</code> 指令可以丢弃已有的更改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout -- &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="撤销暂存"><a href="#撤销暂存" class="headerlink" title="撤销暂存"></a>撤销暂存</h2><p>当更改过的文件被提交到暂存区后，可以重新撤回到工作区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset HEAD &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>删除一个被 git 追踪的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">rm</span> &lt;file&gt;<br></code></pre></td></tr></table></figure><p>与使用系统指令直接删除不同的是，文件删除之后会出现在暂存区，可以从暂存区中撤销到工作区，也可以再从工作区撤销更改，文件就会被恢复。</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">mv</span> &lt;file name&gt; &lt;new file name&gt;<br></code></pre></td></tr></table></figure><p>此时文件会被存放到暂存区，显示为对文件进行了一个 R（rename） 操作</p><h2 id="修改已提交的信息"><a href="#修改已提交的信息" class="headerlink" title="修改已提交的信息"></a>修改已提交的信息</h2><p>当用户写错了一个提交信息并向修正信息时可以使用以下指令修正信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git commit --amend -m <span class="hljs-string">&#x27;纠正过的提交信息&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>amend: 修正</p></blockquote><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><ul><li><code>*.a</code> 忽略所有 .a 结尾的文件</li><li><code>!lib.a</code> 在上述的忽略规则中 lib.a 除外</li><li><code>/TODO</code> 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODO</li><li><code>build/</code> 忽略 build&#x2F; 目录下的所有文件</li><li><code>doc/*.txt</code> 会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</li></ul><h1 id="5-分支"><a href="#5-分支" class="headerlink" title="5. 分支"></a>5. 分支</h1><h2 id="分支查看"><a href="#分支查看" class="headerlink" title="分支查看"></a>分支查看</h2><p>查看当前版本库的所有分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch<br></code></pre></td></tr></table></figure><p><img src="http://img.cdn.esunr.xyz/markdown/20191210112942.png"></p><p>查看本地分支以及远程分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -a<br></code></pre></td></tr></table></figure><p>查看各分支最近一次提交的记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -v<br></code></pre></td></tr></table></figure><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch &lt;branch name&gt;<br>git checkout -b &lt;branch name&gt; <span class="hljs-comment"># 创建并切换到新分支</span><br></code></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git 分支的切换也用的是 <code>checkout</code> 指令，这与文件的签出要进行区别，文件的签出是将文件从工作区撤销更改，而分支的签出是改变分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout &lt;branch name&gt;<br>git checkout - <span class="hljs-comment"># 切换到上一个分支</span><br></code></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>git 不可以删除当前分支，删除分支前需要切换到别的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -d &lt;branch name&gt;<br></code></pre></td></tr></table></figure><p>如果删除的目标分支被改动且没有被合并过，则分支需要使用强制删除：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -D &lt;branch name&gt;<br></code></pre></td></tr></table></figure><p>删除远程分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push origin --delete &lt;branch name&gt;<br></code></pre></td></tr></table></figure><p>删除当前分支外的所有分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch | xargs git branch -d<br></code></pre></td></tr></table></figure><p>删除分支名包含指定字符的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch | grep <span class="hljs-string">&#x27;dev*&#x27;</span> | xargs git branch -d<br></code></pre></td></tr></table></figure><p>删除远程不存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote prune origin<br></code></pre></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git merge &lt;target branch&gt; &lt;branch&gt;  <span class="hljs-comment"># 将 branch 的最新修改合并到 target branch 中</span><br>git merge &lt;branch&gt;                  <span class="hljs-comment"># 将 branch 的最新修改合并到当前分支</span><br></code></pre></td></tr></table></figure><p>如果将某一个分支（branch）的最新修改合并到目标分支（target branch）上，那么目标分支（target branch）的文件会处于修改的最新版本，而合并的分支（branch）并不会拥有目标分支（target branch）的新内容。如果需要目标分支（target branch）的新内容，则需要将目标分支合并到该分支上。</p><h2 id="HEAD-与-master"><a href="#HEAD-与-master" class="headerlink" title="HEAD 与 master"></a>HEAD 与 master</h2><p>HEAD 指的是当前分支，master 指的是当前提交的版本：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20191210141717.png"></p><p>当用户新创建了一个 dev 分支，最新的分支还是会指向当前 master 主分支指向的节点：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20191210142013.png"></p><p>当用户在 dev 分支进行提交后，dev 分支会新建一个版本并指向新版本的提交：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20191210142110.png"></p><p>当 master 分支上没有进行更改，此时合并 dev 与 master 分支的话，master 分支的指针会直接指向当前的版本，我们称这样的操作为 “快进（fast forward）”：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20191210142312.png"></p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>当我们将 dev 分支的最新内容合并到 master 分支时如果出现了冲突需要手动解决冲突，冲突的文件会内容会被标识为类似：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">new file<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">master edit</span><br><span class="hljs-section">=======</span><br>dev edit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev<br></code></pre></td></tr></table></figure><p>此时我们需要手动进入到文件中，将不需要的代码删除，然后再进行一次提交，这样就解决了冲突。</p><p>当此时切回到 dev 分支后，如果想要获取到最新的 master 分支的内容，则需要将 master 分支合并到 dev 分支，此时由于 master 分支被标记为最新更改，所以如果在 dev 分支上没有对已在 master 分支解决了冲突的文件进行修改，dev 分支就会直接快进到 master 分支的版本。</p><p>实际上冲突也是另外开了一个冲突分支，我们解决冲突就是去合并冲突分支：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20191210152834.png"></p><h2 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h2><p>如果可能，git 提交会使用 fast-forward 模式，在这种模式下合并分支并未生成一个新的提交，而是将当前分支的指针指向了</p><h1 id="6-子模块"><a href="#6-子模块" class="headerlink" title="6. 子模块"></a>6. 子模块</h1><h2 id="子模块初始化"><a href="#子模块初始化" class="headerlink" title="子模块初始化"></a>子模块初始化</h2><p>项目有子模块，Clone 后需要进行初始化：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule init     <span class="hljs-comment"># 初始化子模块信息</span><br>git submodule update   <span class="hljs-comment"># 拉去子模块更新</span><br></code></pre></td></tr></table></figure><p>上面两个模块可以合并为一个：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule update --init<br></code></pre></td></tr></table></figure><h2 id="拉取子模块上游更新"><a href="#拉取子模块上游更新" class="headerlink" title="拉取子模块上游更新"></a>拉取子模块上游更新</h2><blockquote><p>–recursive 为递归</p></blockquote><p>从远程源拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule update --recursive --remote<br></code></pre></td></tr></table></figure><blockquote><p>远程源默认拉取 master 分支，如果需要更改拉取分支，则需要在 .gitmodules 文件中添加 branch 信息</p></blockquote><p>从本地 url 源拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule update --init --recursive<br></code></pre></td></tr></table></figure><p>手动递归拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule foreach git pull origin &lt;branch&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa中的的错误处理方案</title>
    <link href="/2022/11/504859a2cea8.html"/>
    <url>/2022/11/504859a2cea8.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-在-async-函数中错误捕获"><a href="#1-在-async-函数中错误捕获" class="headerlink" title="1. 在 async 函数中错误捕获"></a>1. 在 async 函数中错误捕获</h1><p>我们通常处理 Promise 异步操作中的错误可以使用 <code>.catch(err=&gt;&#123; ... &#125;)</code> 来处理，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getAsyncData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功啦&quot;</span>)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错啦&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>但是如果在 Koa 的路由处理函数中，使用这种方式去处理响应数据是无效的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ctx, next</span>)=&gt;</span>&#123;<br>  <span class="hljs-title function_">getAsyncData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    ctx.<span class="hljs-property">body</span> = &#123;<br>      <span class="hljs-attr">ok</span>: ture,<br>      <span class="hljs-attr">data</span>: data,<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    ctx.<span class="hljs-property">body</span> = &#123;<br>      <span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">msg</span>: err.<span class="hljs-property">message</span><br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样做前端调用该路由函数时，返回的结果为 404 。这其实是跟 JS 的事件轮询相关的，我们很容易就想明白，在异步函数中又创建了一个新的异步函数，新的异步函数的回调执行顺序肯定在当前异步函数的回调执行完毕之后。</p><p>也就是说，假如我们以这样的方式处理错误的话，当我们执行 <code>ctx.body</code> 赋值数据时，当前的请求已经发送完毕了，所以 <code>ctx.body</code> 是不能在内层的异步函数中调用的。如果我们需要通过异步获取数据，我们应该在当前的异步函数中使用 <code>await</code> 来阻塞数据获取的异步函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ctx, next</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAsycnData</span>()<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">ok</span>: ture,<br>    <span class="hljs-attr">data</span>: data,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，这样的话我们就无法捕捉错误了。如果想捕捉 <code>await</code> 的异步函数中的错误实际上也可以直接使用 <code>catch()</code> 来捕获，如像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ctx, next</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAsycnData</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    ctx.<span class="hljs-property">body</span> = &#123;<br>      <span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">data</span>: data,<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;)<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">data</span>: data,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样的话，的确是可以捕获到错误，但是这样我们就会发现，由于执行顺序的问题，<code>ctx.body</code> 的操作会被后续的操作覆盖，我们无法在处理完错误后终止处理后续的逻辑。</p><p>但是 JS 中的 <code>try...catch...</code> 可以解决这个问题，我们只需要将其改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ctx, next</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAsycnData</span>()<br>      ctx.<span class="hljs-property">body</span> = &#123;<br>      <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">data</span>: data,<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (e)&#123;<br>    ctx.<span class="hljs-property">body</span> = &#123;<br>      <span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">msg</span>: e.<span class="hljs-property">message</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样处理的话，当在等待异步函数 <code>getAsycnData()</code> 时如果出现了错误，就会从中途跳出，被捕获到 <code>catch</code> 语句中，从而执行错误处理的函数。</p><h1 id="2-错误的聚合处理"><a href="#2-错误的聚合处理" class="headerlink" title="2. 错误的聚合处理"></a>2. 错误的聚合处理</h1><p>我们可以在每个路由处理函数中都使用如上的方法处理错误，但是这样还是不够便捷，我们希望可以将出错信息进行聚合最后返回给请求者。我们可以利用 Koa 的中间件执行方式，将错误处理函数作为一个中间件函数，放在所用中间件的顶部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    ctx.<span class="hljs-property">status</span> = err.<span class="hljs-property">status</span> || <span class="hljs-number">500</span><br>    ctx.<span class="hljs-property">body</span> = err.<span class="hljs-property">message</span><br>    ctx.<span class="hljs-property">app</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;error&quot;</span>, err, ctx)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样当 Koa 执行到该中间件时，会首先执行 <code>await next()</code> 然后执行后续的中间件，当其余中间件执行过程中出错，就会跳出到 <code>catch</code> 语句中，返回错误信息给数据请求者。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus Webpack 下按需引入</title>
    <link href="/2022/11/0b2c4e0a8c7c.html"/>
    <url>/2022/11/0b2c4e0a8c7c.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-引入方案"><a href="#1-引入方案" class="headerlink" title="1. 引入方案"></a>1. 引入方案</h1><p>官方说明：<a href="https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5">链接</a></p><p>我们需要在 Webpack 配置里添加两个 Plugin：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> autoImport <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/webpack&#x27;</span>;<br><span class="hljs-keyword">import</span> components <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/webpack&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ElementPlusResolver</span> <span class="hljs-keyword">as</span> elementPlusResolver&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span>;<br><br><span class="hljs-comment">// ... ...</span><br><span class="hljs-attr">plugins</span>: [<br><span class="hljs-title function_">autoImport</span>(&#123;<br><span class="hljs-attr">resolvers</span>: [<span class="hljs-title function_">elementPlusResolver</span>()],<br>&#125;),<br><span class="hljs-title function_">components</span>(&#123;<br><span class="hljs-attr">resolvers</span>: [<br><span class="hljs-title function_">elementPlusResolver</span>(),<br>],<br>&#125;),<br>],<br></code></pre></td></tr></table></figure><h2 id="1-1-unplugin-auto-import"><a href="#1-1-unplugin-auto-import" class="headerlink" title="1.1 unplugin-auto-import"></a>1.1 unplugin-auto-import</h2><blockquote><p><a href="https://github.com/antfu/unplugin-auto-import">https://github.com/antfu/unplugin-auto-import</a></p></blockquote><p><code>autoImport</code> 是用来帮助我们自动引用 Element 组件的，当你在 vue 组件里编写入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>你这瓜多少钱一斤<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么经过编译后，<code>autoImport</code> 会自动帮我们吧 ElButton 组件给引入，那么代码就会成为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>你这瓜多少钱一斤<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;ElButton&quot;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但这时候代码还不能使用，因为 <code>defineComponent</code> 的 <code>components</code> 中还没有定义 ElButton 组件，此时我们就需要使用 unplugin-vue-components</p><h2 id="1-2-unplugin-vue-components"><a href="#1-2-unplugin-vue-components" class="headerlink" title="1.2 unplugin-vue-components"></a>1.2 unplugin-vue-components</h2><blockquote><p><a href="https://github.com/antfu/unplugin-vue-components">https://github.com/antfu/unplugin-vue-components</a></p></blockquote><p>unplugin-vue-components 导出的 <code>components</code> 可以帮我们自动定义组件中用到的子组件，承接前面的代码，使用了 unplugin-vue-components 后，代码就会被编译为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>你这瓜多少钱一斤<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;ElButton&quot;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">component</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title class_">ElButton</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 但是此时只是导入了组件，组件的样式还没有被引入，这时候就需要 unplugin-vue-components&#x2F;resolvers 下导出的 <code>ElementPlusResolver</code> 了。</p><p> <code>ElementPlusResolver</code> 提供了组件标签和组件引入位置的映射关系，因此我们需要将其作为 resolver 传入前面提到的<code>autoImport</code> 和 <code>componet</code> 两个插件中，这样两个插件才知道我们在 template 里面写的组件标签需要引用到哪些组件，然后来帮我们引入和声明。</p><p> 除此之外，<code>ElementPlusResolver</code> 还可以帮我们自动引入组件的样式，通过配置它的 <code>importStyle</code> 配置项，我们还可以禁用这个功能，或者让其引入 css 文件（默认）或者 scss 文件。</p><p> 使用了 <code>ElementPlusResolver</code> 后，代码就会被编译为：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>你这瓜多少钱一斤<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;ElButton&quot;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/es/components/button/style/css&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">component</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title class_">ElButton</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此外，在项目里如果你的一些全局组件放在 <code>src/components</code> 目录下，当你在其他组件中使用时，unplugin-vue-components 也会自动将这些组件自动引入并声明。</p><p>同时 unplugin-vue-components 自动导入的组件也是支持 typescript 的，将 <code>component</code> 插件的 <code>dts</code> 属性设置为 true 后，会在项目根目录生成一个 <code>components.d.ts</code> 文件，如果你的编辑器使用了 volar，并且把这个 dts 文件添加 tsconfig 文件之后，在使用这些被自动引入的组件时便会出现 ts 提示。</p><blockquote><p>这里不建议将业务组件也完全依赖自动引入，因为不同模块间的业务组件可能存在同名情况。</p></blockquote><h1 id="2-按需引入时，如何自定义样式"><a href="#2-按需引入时，如何自定义样式" class="headerlink" title="2. 按需引入时，如何自定义样式"></a>2. 按需引入时，如何自定义样式</h1><p>自定义相关的样式，ElementPlus 官网的说明很少，但是从源码里可以翻到一个 README：<a href="https://github.com/element-plus/element-plus/blob/1.1.0-beta.20/docs/en-US/guide/theming.md">https://github.com/element-plus/element-plus/blob/1.1.0-beta.20/docs/en-US/guide/theming.md</a></p><p>按照上面的说明我们需要创建一个样式文件，并将其放在 <code>stlye/element-variable.scss</code> 目录下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// README: https://github.com/element-plus/element-plus/blob/1.1.0-beta.20/docs/en-US/guide/theming.md</span><br><span class="hljs-keyword">@forward</span> <span class="hljs-string">&quot;element-plus/theme-chalk/src/common/var.scss&quot;</span> with (<br>// 注意：<span class="hljs-number">1.2</span>.<span class="hljs-number">0</span>+ 移除了 IconFont，不要按照原文 Demo 中添加 <span class="hljs-variable">$font-path</span> 变量<br>    // <span class="hljs-variable">$font-path</span>: <span class="hljs-string">&#x27;~element-plus/dist/fonts&#x27;</span>,<br>    // 主题颜色<br>    <span class="hljs-variable">$colors</span>: (<br>        <span class="hljs-string">&#x27;primary&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#303CB9</span>,<br>        ),<br>        <span class="hljs-string">&#x27;success&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#67c23a</span><br>        ),<br>        <span class="hljs-string">&#x27;warning&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#e6a23c</span><br>        ),<br>        <span class="hljs-string">&#x27;danger&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#ed3637</span><br>        ),<br>        <span class="hljs-string">&#x27;error&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#f56c6c</span><br>        ),<br>        <span class="hljs-string">&#x27;info&#x27;</span>: (<br>            <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#909399</span><br>        ),<br>    ),<br>    // 字体颜色<br>    <span class="hljs-variable">$text-color</span>: (<br>        <span class="hljs-string">&#x27;primary&#x27;</span>: <span class="hljs-number">#1D2024</span>,<br>        <span class="hljs-string">&#x27;regular&#x27;</span>: <span class="hljs-number">#505255</span>,<br>        <span class="hljs-string">&#x27;secondary&#x27;</span>: <span class="hljs-number">#C0C4CC</span>,<br>        <span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-number">#C0C4CC</span>,<br>    )<br>);<br><span class="hljs-comment">// 因为我们采用按需引入方式来引入组件，因此不要全局引入样式文件</span><br><span class="hljs-comment">// @use &quot;~element-plus/theme-chalk/src/index&quot;;</span><br></code></pre></td></tr></table></figure><p>然后在 Vue 入口文件 main.ts 里引入：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/stlye/element-variable.scss&quot;</span><br></code></pre></td></tr></table></figure><p>之后我们便会发现，并没有什么用 … … 定义的变量并没有生效。</p><p>其实经过分析 unplugin-auto-import 和 unplugin-vue-components 的自动引入组件原理后，我们不难发现两个插件帮我们引入的组件样式实际上是在 <strong>组件内部生效的</strong>，然而我们定义的变量文件却是在入口文件引入的，因此组件内部引入的哪些样式是取不到我们这里定义的全局变量的。</p><p>那么，怎么才能生效呢？我们不妨来想一下如果你定义了一个样式文件（variable.scss）来存储变量信息，你要怎么在其他样式文件中使用这个样式文件呢？没错，就是在其他文件内引入 <code>variable.scss</code>，就像这样：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;@/style/variables.scss&quot;</span> as *;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>backgournd: <span class="hljs-variable">$-bg-color</span><br>&#125;<br></code></pre></td></tr></table></figure><p>沿着这个思路，我们只要想办法将 <code>@use &quot;@/stlye/element-variable.scss&quot; as *;</code> 塞入每个 ElementPlus 组件的 scss 样式文件的第一行中就可以了。</p><p><code>sass-loader</code> 正好提供了一个 <code>additionalData</code> 配置项，可以帮助们我们来将一些信息写入到每个 scss 文件中，因此我们需要在 webpack 的 scss loader 部分配置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,<br><span class="hljs-attr">use</span>: [<br>process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span> ? <span class="hljs-string">&#x27;vue-style-loader&#x27;</span> : <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,<br><span class="hljs-string">&#x27;css-loader&#x27;</span>,<br><span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>&#123;<br><span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;sass-loader&#x27;</span>,<br><span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">additionalData</span>: <span class="hljs-string">&#x27;@use &quot;@/stlye/element-variable.scss&quot; as *;&#x27;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&#x27;css-unicode-loader&#x27;</span>,<br>],<br>&#125;,<br></code></pre></td></tr></table></figure><p>同时，因为 <code>ElementPlusResolver</code> 默认引入的是 ElementPlus 中的 css 文件，我们需要让其引入 scss 文件行，我们还需要将 plugin 做一下改造：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff">plugins: [<br>autoImport(&#123;<br>resolvers: [<br><span class="hljs-deletion">-elementPlusResolver()</span><br><span class="hljs-addition">+elementPlusResolver(&#123;</span><br><span class="hljs-addition">+importStyle: &#x27;sass&#x27;,</span><br><span class="hljs-addition">+&#125;),</span><br>],<br>&#125;),<br>components(&#123;<br>resolvers: [<br><span class="hljs-deletion">-elementPlusResolver(),</span><br><span class="hljs-addition">+elementPlusResolver(&#123;</span><br><span class="hljs-addition">+importStyle: false, // 两个 elementPlusResolver 都会自动引入样式文件，可以关闭一个</span><br><span class="hljs-addition">+&#125;),</span><br>],<br>&#125;),<br>]<br></code></pre></td></tr></table></figure><p>之后我们定义的 ElementPlus 变量就可以完美使用了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>Vue</tag>
      
      <tag>Element-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useState 的简易实现</title>
    <link href="/2022/07/ab38a0767610.html"/>
    <url>/2022/07/ab38a0767610.html</url>
    
    <content type="html"><![CDATA[<p>首先 利用闭包的特性 将 state 声明到 function 之外 使得数据持久化</p><blockquote><p>useState.ts</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">state</span>: <span class="hljs-built_in">unknown</span><br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../../main&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> &lt;T&gt;(<span class="hljs-attr">initialState</span>: T): <span class="hljs-keyword">readonly</span> [T, <span class="hljs-function">(<span class="hljs-params">state: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>] &#123;<br>  state = state ? state : initialState<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">newState: T</span>): <span class="hljs-built_in">void</span> &#123;<br>    state = newState<br>    <span class="hljs-title function_">render</span>()<br>  &#125;<br>  <span class="hljs-comment">// state as T 暂时不知如何解决</span><br>  <span class="hljs-keyword">return</span> [state <span class="hljs-keyword">as</span> T, setState] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时这里导入的 render 是 main.tsx 的渲染函数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)!)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  root.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-title function_">render</span>()<br></code></pre></td></tr></table></figure><blockquote><p>index.tsx</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> useState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hooks/useState&#x27;</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span> &#123;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">testUseState</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">Props</span>&gt; = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = useState&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>testUseState<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;state&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setState(state + 1)</span><br><span class="language-xml">          console.log(state)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        handle click state</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> testUseState<br></code></pre></td></tr></table></figure><p>此时的 state 就是一个简易版的 hook 这样的 hook 有一个缺点 他就是一个<code>state</code>单例的 hooks</p><p>useState 应该要调用多次 每次应该生成不同的 state 数据 这时的 state 和 setState 都应该是一个数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../../main&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">state</span>: <span class="hljs-built_in">unknown</span>[] = []<br><span class="hljs-comment">// 用于存储改变state的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">setState</span>: (<span class="hljs-function">(<span class="hljs-params">state: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>)[] = []<br><span class="hljs-keyword">let</span> stateIndex = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 改进setState</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">newState: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> &#123;<br>    state[index] = newState<br>    <span class="hljs-title function_">render</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      stateIndex = <span class="hljs-number">0</span><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> &lt;T&gt;(<span class="hljs-attr">initialState</span>: T) &#123;<br>  <span class="hljs-comment">// 初始化state</span><br>  state[stateIndex] = state[stateIndex] ? state[stateIndex] : initialState<br>  <span class="hljs-comment">// 初始化setState</span><br>  <span class="hljs-comment">// setState[stateIndex] = ((index: number) =&gt; &#123;</span><br>  <span class="hljs-comment">//   return (newState: unknown) =&gt; &#123;</span><br>  <span class="hljs-comment">//     state[index] = newState;</span><br>  <span class="hljs-comment">//     // 每次调用玩应该重新刷新页面</span><br>  <span class="hljs-comment">//     render(() =&gt; &#123;</span><br>  <span class="hljs-comment">//       // render的时候应该将stateIndex 重置为 0</span><br>  <span class="hljs-comment">//       stateIndex = 0;</span><br>  <span class="hljs-comment">//     &#125;);</span><br>  <span class="hljs-comment">//   &#125;;</span><br>  <span class="hljs-comment">// &#125;)(stateIndex);</span><br>  <span class="hljs-comment">// ! 改进setState[]</span><br>  setState[stateIndex] = <span class="hljs-title function_">createSetter</span>(stateIndex)<br>  <span class="hljs-comment">// 每次调用一个useStateMany时，stateIndex++ 使得可以存储多个值</span><br>  stateIndex++<br><br>  <span class="hljs-keyword">return</span> [state[stateIndex - <span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> T, setState[stateIndex - <span class="hljs-number">1</span>]] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时的 state 和 state2 的数据将互不干扰</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> useStateMany <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hooks/useStateMany&#x27;</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span> &#123;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StateMany</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">Props</span>&gt; = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = useStateMany&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [state2, setState2] = useStateMany&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>StateMany<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">            setState(state + 1)</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;</span><br><span class="language-xml">          handle click state</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">            setState2(state2 + 1)</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;</span><br><span class="language-xml">          handle click state2</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">StateMany</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vuex Typescript 支持</title>
    <link href="/2022/07/f672fc109ff3.html"/>
    <url>/2022/07/f672fc109ff3.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><h2 id="1-1-定义入口模块"><a href="#1-1-定义入口模块" class="headerlink" title="1.1 定义入口模块"></a>1.1 定义入口模块</h2><p>入口 <code>/src/store/index.ts</code> :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">InjectionKey</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;createStore, <span class="hljs-title class_">Store</span>, useStore <span class="hljs-keyword">as</span> baseUseStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-comment">// 引入子模块</span><br><span class="hljs-keyword">import</span> createUserState, &#123;<span class="hljs-title class_">IUserState</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRootState</span> &#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IModuleState</span> &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-title class_">IUserState</span>;<br><span class="hljs-comment">// other modules</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">storeInjectionKey</span>: <span class="hljs-title class_">InjectionKey</span>&lt;<span class="hljs-title class_">Store</span>&lt;<span class="hljs-title class_">IRootState</span> &amp; <span class="hljs-title class_">IModuleState</span>&gt;&gt; = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;storeInjectionKey&#x27;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initStore</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> createStore&lt;<span class="hljs-title class_">IRootState</span>&gt;(&#123;<br>        <span class="hljs-attr">state</span>: &#123;&#125;,<br>        <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>        <span class="hljs-attr">actions</span>: &#123;&#125;,<br>        <span class="hljs-attr">modules</span>: &#123;<br>            <span class="hljs-attr">user</span>: <span class="hljs-title function_">createUserState</span>(),<br><span class="hljs-comment">// other modules</span><br>        &#125;,<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 定义自己的 `useStore` 组合式函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useStore</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseUseStore</span>(storeInjectionKey);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-定义子模块"><a href="#1-2-定义子模块" class="headerlink" title="1.2 定义子模块"></a>1.2 定义子模块</h2><p>User 模块 <code>/src/store/user.ts</code> :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">InjectionKey</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Store</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">Module</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">IRootState</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;.&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;getUserDetail, getUserStatus&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/base/api/user&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">IS_NODE</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/base/utils&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDetail</span> &#123;<br>    id?: <span class="hljs-built_in">number</span>;<br>    ucid?: <span class="hljs-built_in">string</span>;<br>    unfinished_orders_num?: <span class="hljs-built_in">number</span>;<br>    orders_num?: <span class="hljs-built_in">number</span>;<br>    has_saas?: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义 UserState 的接口</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserState</span> &#123;<br>    <span class="hljs-attr">isLogin</span>: <span class="hljs-built_in">boolean</span>;<br>    ucid?: <span class="hljs-built_in">string</span>;<br>    ucname?: <span class="hljs-built_in">string</span>;<br>    loginType?: <span class="hljs-string">&#x27;uc&#x27;</span>;<br>    detail?: <span class="hljs-title class_">IUserDetail</span>;<br>&#125;<br><br><span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">storeUserKey</span>: <span class="hljs-title class_">InjectionKey</span>&lt;<span class="hljs-title class_">Store</span>&lt;<span class="hljs-title class_">IUserState</span>&gt;&gt; = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;storeUserKey&#x27;</span>);<br><br><span class="hljs-comment">// 导出一个创建 State Module 的方法，防止在 SSR 场景下每个请求都使用同一个实例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserState</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Module</span>&lt;<span class="hljs-title class_">IUserState</span>, <span class="hljs-title class_">IRootState</span>&gt; &#123;<br>    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>        <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">false</span>,<br>    &#125;),<br>    <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-title function_">setLoginStatus</span>(<span class="hljs-params">state, payload</span>) &#123;<br>            state.<span class="hljs-property">isLogin</span> = payload.<span class="hljs-property">isLogin</span>;<br>            state.<span class="hljs-property">loginType</span> = payload.<span class="hljs-property">loginType</span>;<br>        &#125;,<br>        <span class="hljs-title function_">setLoginInfo</span>(<span class="hljs-params">state, payload</span>) &#123;<br>            state.<span class="hljs-property">ucid</span> = payload.<span class="hljs-property">ucid</span>;<br>            state.<span class="hljs-property">ucname</span> = payload.<span class="hljs-property">ucname</span>;<br>        &#125;,<br>        <span class="hljs-title function_">setUserDetail</span>(<span class="hljs-params">state, payload</span>) &#123;<br>            state.<span class="hljs-property">detail</span> = payload;<br>        &#125;,<br>        <span class="hljs-title function_">setLoginOut</span>(<span class="hljs-params">state</span>) &#123;<br>            state.<span class="hljs-property">isLogin</span> = <span class="hljs-literal">false</span>;<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-attr">getUserStatus</span>: <span class="hljs-keyword">async</span> (store, payload) =&gt; &#123;<br>            <span class="hljs-comment">// do somethings</span><br>        &#125;,<br>        <span class="hljs-attr">getUserDetail</span>: <span class="hljs-keyword">async</span> (store, payload) =&gt; &#123;<br>            <span class="hljs-comment">// do somethings</span><br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;&#125;,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createUserState<br></code></pre></td></tr></table></figure><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;useStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/src/store&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123;state, dispatch&#125; = <span class="hljs-title function_">useStore</span>();<br><br><span class="hljs-keyword">const</span> ucid = <span class="hljs-title function_">computed</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>?.<span class="hljs-property">ucid</span>)<br><span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/getUserStatus&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nextTick 源码解析</title>
    <link href="/2022/07/fc68235f5823.html"/>
    <url>/2022/07/fc68235f5823.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vue DOM 更新采用的是异步的更新策略 每次监听到数据发生变化的时候 不会立即取更新 DOM 而是将这一次更新 DOM 的事件缓存到一个任务队列中<br><strong>这样的好处就是可以将多次更新数据的操作合并成一次 并且减少操作 DOM 的次数</strong></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>nextTick 接收一个回调函数作为参数 这个回调函数会在 DOM 更新之后才执行 因此对基于最新的数据生成的DOM进行操作的时候 可以将改操作放入nextTick中</p><blockquote><p><a href="https://github.com/vuejs/vue/blob/main/src/core/util/next-tick.ts">源码地址：</a><a href="https://github.com/vuejs/vue/blob/main/src/core/util/next-tick.ts">https://github.com/vuejs/vue/blob/main/src/core/util/next-tick.ts</a></p></blockquote><p>nextTick 提供了四种异步的方法: <code>Promise.then</code>、<code>MutationObserver</code>、<code>setTimeout</code>、<code>setImmediate</code><br>前两种是微任务 后两种是宏任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* globals MutationObserver */</span><br><br><br><span class="hljs-comment">// noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错</span><br><span class="hljs-keyword">import</span> &#123; noop &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;shared/util&#x27;</span><br><span class="hljs-comment">// handleError 是一个错误处理函数，用于捕获异步操作中的错误</span><br><span class="hljs-keyword">import</span> &#123; handleError &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./error&#x27;</span><br><span class="hljs-comment">//  isIE, isIOS, isNative 环境判断函数，</span><br><span class="hljs-comment">//  isNative 判断某个属性或方法是否原生支持，如果不支持或通过第三方实现支持都会返回 false</span><br><span class="hljs-keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./env&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> isUsingMicroTask = <span class="hljs-literal">false</span> <span class="hljs-comment">// 标记nextTick是否以微任务执行</span><br><br><span class="hljs-comment">// 维持一个回调函数队列</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">callbacks</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt; = []<br><br><span class="hljs-comment">// 用来控制任务队列依次能够推入 event loop 中</span><br><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 开始批量执行更新队列的操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushCallbacks</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 恢复等待状态</span><br>  pending = <span class="hljs-literal">false</span><br>  <span class="hljs-comment">// 浅拷贝一份任务队列 并且将任务队列清空</span><br>  <span class="hljs-comment">// 防止在任务队列的回调函数中如果再调用nextTick函数 导致nextTick执行时机错乱的问题 而且可能会出现一只循环的问题</span><br>  <span class="hljs-comment">// nextTick 中 在调用 nextTick 此次的nextTick应该在下一次的时机执行</span><br>  <span class="hljs-keyword">const</span> copies = callbacks.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)<br>  callbacks.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.<span class="hljs-property">length</span>; i++) &#123;<br>    copies[i]()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Here we have async deferring wrappers using microtasks.</span><br><span class="hljs-comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span><br><span class="hljs-comment">// However, it has subtle problems when state is changed right before repaint</span><br><span class="hljs-comment">// (e.g. #6813, out-in transitions).</span><br><span class="hljs-comment">// Also, using (macro) tasks in event handler would cause some weird behaviors</span><br><span class="hljs-comment">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span><br><span class="hljs-comment">// So we now use microtasks everywhere, again.</span><br><span class="hljs-comment">// A major drawback of this tradeoff is that there are some scenarios</span><br><span class="hljs-comment">// where microtasks have too high a priority and fire in between supposedly</span><br><span class="hljs-comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span><br><span class="hljs-comment">// or even between bubbling of the same event (#6566).</span><br><br><span class="hljs-comment">// 异步支持的方法：</span><br><span class="hljs-keyword">let</span> timerFunc<br><br><span class="hljs-comment">// 判断当前环境优先支持的异步方法，优先选择微任务</span><br><span class="hljs-comment">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span><br><span class="hljs-comment">// setTimeout 可能产生一个 4ms 的延迟，而 setImmediate 会在主线程执行完后立刻执行</span><br><span class="hljs-comment">// setImmediate 在 IE10 和 node 中支持</span><br><br><span class="hljs-comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span><br><span class="hljs-comment">// via either native Promise.then or MutationObserver.</span><br><span class="hljs-comment">// MutationObserver has wider support, however it is seriously bugged in</span><br><span class="hljs-comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span><br><span class="hljs-comment">// completely stops working after triggering a few times... so, if native</span><br><span class="hljs-comment">// Promise is available, we will use it:</span><br><span class="hljs-comment">/* istanbul ignore next, $flow-disable-line */</span><br><br><span class="hljs-comment">// 判断是否支持Promise</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 利用then 将 flushCallbacks 包裹成一个异步的微任务</span><br>    p.<span class="hljs-title function_">then</span>(flushCallbacks)<br>    <span class="hljs-comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span><br>    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span><br>    <span class="hljs-comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span><br>    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span><br>    <span class="hljs-comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  <span class="hljs-comment">// 标志为微任务</span><br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>  <span class="hljs-comment">// 如果不是ie并且浏览器支持 MutationObserver 也是一个微任务</span><br>  !isIE &amp;&amp;<br>  <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp;<br>  (<span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) ||<br>    <span class="hljs-comment">// PhantomJS and iOS 7.x</span><br>    <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span>)<br>) &#123;<br>  <span class="hljs-comment">// Use MutationObserver where native Promise is not available,</span><br>  <span class="hljs-comment">// e.g. PhantomJS, iOS7, Android 4.4</span><br>  <span class="hljs-comment">// (#6466 MutationObserver is unreliable in IE11)</span><br>  <span class="hljs-comment">// 利用 MutationObserver 改变 textNode的文本内容 触发flushCallbacks回调</span><br>  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks)<br>  <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter))<br>  observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>    <span class="hljs-comment">// @see: https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/MutationObserver/observe_2f2addbfa1019c23a6255648d6526387</span><br>    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 改变内容 触发更新</span><br>    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123;<br>  <span class="hljs-comment">// Fallback to setImmediate.</span><br>  <span class="hljs-comment">// Technically it leverages the (macro) task queue,</span><br>  <span class="hljs-comment">// but it is still a better choice than setTimeout.</span><br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setImmediate</span>(flushCallbacks)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// Fallback to setTimeout.</span><br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params">cb: (...args: any[]) =&gt; any, ctx?: object</span>): <span class="hljs-keyword">void</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@internal</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params">cb?: (...args: any[]) =&gt; any, ctx?: object</span>) &#123;<br>  <span class="hljs-comment">// 用于执行nextTick().then的操作</span><br>  <span class="hljs-keyword">let</span> _resolve<br>  <span class="hljs-comment">// 压入一个回调函数至任务队列中</span><br>  callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        cb.<span class="hljs-title function_">call</span>(ctx)<br>      &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-attr">e</span>: any) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>      <span class="hljs-title function_">_resolve</span>(ctx)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">// pending 为一个标识符 只有在上一次的timerFunc执行 才能将下一次的任务队列推入到 event loop 中</span><br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span><br>    <span class="hljs-title function_">timerFunc</span>()<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise</span><br>    <span class="hljs-comment">// 此时外部通过.then执行的时候 DOM已经更新好了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      _resolve = resolve<br>    &#125;)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/7087866362785169416">nextTick实现原理</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">mdn MutationObserver</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于ES6中import、export语句的种种引入方式、导出方式的区别</title>
    <link href="/2022/07/08ae56588ea6.html"/>
    <url>/2022/07/08ae56588ea6.html</url>
    
    <content type="html"><![CDATA[<p>学习了这么长时间的Vue、React、还有nodeJs，对 <code>import</code> 语句可以说是既熟练又容易糊涂，我们经常见到以下几种 <code>import</code> 语句：</p><ul><li>import {xx1, xx2, xx2} from ‘xx’</li><li>improt * as xx from ‘xx’</li><li>import xx from ‘xx’</li></ul><p>那么接下来我们就好好分析一下他们的区别以及使用场景：</p><h2 id="1-import-xx1-xx2-xx2-from-‘xx’"><a href="#1-import-xx1-xx2-xx2-from-‘xx’" class="headerlink" title="1. import {xx1, xx2, xx2} from ‘xx’"></a>1. import {xx1, xx2, xx2} from ‘xx’</h2><p>该语句是引入外部模块中的某个接口，外部模块向外暴露出某个接口后，在主模块中可以引用该模块文件及其接口名称，即可调用该接口。需要注意的是，其接口名称是一一对应的关系。</p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>导出模块的方法基本上分为两种，一种是使用 <code>export</code> 语法分别导出对应的模块接口，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br></code></pre></td></tr></table></figure><p>还有一种就是将以接口的形式聚合导出，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-keyword">export</span> &#123; firstName, lastName, year &#125;;<br></code></pre></td></tr></table></figure><p>同时我们还可以使用 <code>as</code> 语法来对接口名称进行重命名，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-keyword">export</span> &#123; <br>firstName <span class="hljs-keyword">as</span> name1, <br>lastName <span class="hljs-keyword">as</span> name2, <br>year,<br>year <span class="hljs-keyword">as</span> bornYaer<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入模块接口需要按照接口名称一一对应引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; firstName, lastName, year &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">element</span>) &#123;<br>  element.<span class="hljs-property">textContent</span> = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用 <code>as</code> 语法去对模块接口进行重命名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; firstName <span class="hljs-keyword">as</span> name1, lastName <span class="hljs-keyword">as</span> name2, year &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">element</span>) &#123;<br>  element.<span class="hljs-property">textContent</span> = name1 + <span class="hljs-string">&#x27; &#x27;</span> + name2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-improt-as-xx-from-‘xx’"><a href="#2-improt-as-xx-from-‘xx’" class="headerlink" title="2. improt * as xx from ‘xx’"></a>2. improt * as xx from ‘xx’</h2><p>这种加载方式我们称之为模块的整体加载，是用这种方式加载模块，所有的接口都会被加载并且存放到以 <code>as</code> 命名的对象中。</p><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// circle.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">radius</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * radius * radius;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">circumference</span>(<span class="hljs-params">radius</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * radius;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> circle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;圆面积：&#x27;</span> + circle.<span class="hljs-title function_">area</span>(<span class="hljs-number">4</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;圆周长：&#x27;</span> + circle.<span class="hljs-title function_">circumference</span>(<span class="hljs-number">14</span>));<br></code></pre></td></tr></table></figure><blockquote><p>注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p></blockquote><h2 id="3-import-xx-from-‘xx’"><a href="#3-import-xx-from-‘xx’" class="headerlink" title="3. import xx from ‘xx’"></a>3. import xx from ‘xx’</h2><p>这种语法实际上是最常见的，从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。用这种方法可以加载模块文件默认导出的接口，并且按照用户自定义的变量名称去加载该默认接口。</p><blockquote><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p></blockquote><h3 id="导出-2"><a href="#导出-2" class="headerlink" title="导出"></a>导出</h3><p>默认接口使用 <code>export default</code> 语句导出，其可以是一个命名函数方法也可以是一个匿名函数方法。同时使用了 <code>export default</code> 语句导出默认接口的情况下，仍旧可以使用 <code>export</code> 语句导出命名接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h3><p>在主文件中引用该模块可以直接使用 <code>import</code> 语句定义用户自定义变量来引入使用该接口:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import-default.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;<br><span class="hljs-title function_">customName</span>(); <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><p>我们在编写模块导出模块接口时，使用 <code>export</code> 语句导出的变量、方法必须定义在语句之后，不能直接导出匿名函数、数值、字符串，如下面定义的导出都是非法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">export</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> m;<br></code></pre></td></tr></table></figure><blockquote><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。</p></blockquote><p>正确的写法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> &#123;m&#125;;<br><br><span class="hljs-comment">// 写法三</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> &#123;n <span class="hljs-keyword">as</span> m&#125;;<br></code></pre></td></tr></table></figure><p>但是当我们使用 <code>export default</code> 语句时，如果在语句中声明变量，就会产生报错，这点与 <code>export</code> 语句截然相反，其原因是因为 <code>export default</code> 语句实质上相当于导出了一个 <code>defalut</code> 变量，如果我们再语句中再声明一个变量自然就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">export</span> <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript基础概念入门</title>
    <link href="/2022/05/ea3a3f073369.html"/>
    <url>/2022/05/ea3a3f073369.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Array-和-Tuple"><a href="#1-Array-和-Tuple" class="headerlink" title="1. Array 和 Tuple"></a>1. Array 和 Tuple</h1><p>定义数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arrOfNumbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>arrOfNumbers.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>Tuple（元组）类似于数组，但是不同于普通 js 数组，元组可以定义每个位置的数据类型。</p><p>创建元组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;viking&#x27;</span>, <span class="hljs-number">12</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;viking&#x27;</span>] <span class="hljs-comment">// error</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;viking&#x27;</span>] <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h1 id="2-Interface-接口"><a href="#2-Interface-接口" class="headerlink" title="2. Interface 接口"></a>2. Interface 接口</h1><ul><li>对对象的 shape 进行描述</li><li>对类进行抽象</li><li>Duck Typing</li></ul><p>接口的定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 定义只读属性</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">sex</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 定义可选参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口的使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">xiaoming</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Zpangxie&quot;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;man&quot;</span>,<br>&#125;;<br>xiaoming.<span class="hljs-property">age</span> = <span class="hljs-number">19</span>;<br>xiaoming.<span class="hljs-property">id</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>接口不仅可以用来定义对象，还可以用来定义函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAdd</span> &#123;<br>  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">IAdd</span> = add;<br></code></pre></td></tr></table></figure><h1 id="3-Function-函数"><a href="#3-Function-函数" class="headerlink" title="3. Function 函数"></a>3. Function 函数</h1><p>创建函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y + z;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// 5</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><p>我们还可以对变量定义函数类型，如定义变量 <code>add2</code> 为一个传入值为 3 个 number 类型的变量，且返回为 number 类型的函数，那么 <code>add</code> 函数就可以赋值给这个变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">add2</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>add2 = add; <span class="hljs-comment">// success</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">add2</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, c: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>add2 = add; <span class="hljs-comment">// success</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">add2</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>add2 = add; <span class="hljs-comment">// success</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">add2</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>add2 = add; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h1 id="3-Class-类"><a href="#3-Class-类" class="headerlink" title="3. Class 类"></a>3. Class 类</h1><p>类的基本使用与 ES6 相似，在此不再复述，主要区别在于 TS 中支持了类的修饰符：</p><ul><li>public </li><li>private</li><li>protected</li></ul><p>public 属性可以让外部实例直接获取到，默认的属性都为 public；而 private 属性只有在类的内部的方法中可以调用，而外部不可调用，也不可继承：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;walk&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> huahua = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(huahua.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(huahua.<span class="hljs-property">age</span>); <span class="hljs-comment">// error: 属性“age”为私有属性，只能在类“People”中访问。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; <span class="hljs-comment">// error: 属性“age”为私有属性，只能在类“People”中访问。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要想让该属性也可被子类继承，那么可以使用 protected 来对变量进行修饰：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff">  class A`nimal &#123;<br>    public name: string;<br><span class="hljs-deletion">-   private age: number;</span><br><span class="hljs-addition">+   protected age: number;</span><br>    constructor(name: string, age: number) &#123;<br>      ... ...<br>    &#125;<br>    ... ...<br>  &#125;<br><br>  class Dog extends Animal &#123;<br>    constructor(name: string, age: number) &#123;<br>      super(name, age);<br>      this.name = name;<br>      this.age = age;<br>    &#125;<br>  &#125;`<br></code></pre></td></tr></table></figure><p>静态方法与属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">static</span> includes = [<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;bird&quot;</span>];<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ... ...</span><br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAnimal</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">return</span> a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-interface-接口"><a href="#4-interface-接口" class="headerlink" title="4. interface 接口"></a>4. interface 接口</h1><p>定义与实现接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ==== 定义接口 ====</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Radio</span> &#123;<br>  <span class="hljs-title function_">switchRadio</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Battery</span> &#123;<br>  <span class="hljs-title function_">checkBVatteryStatus</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RadioWithBattery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Radio</span> &#123; <span class="hljs-comment">// 接口的继承</span><br>  <span class="hljs-title function_">checkBVatteryStatus</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// ==== 在类中实现接口 ====</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Radio</span> &#123;<br>  <span class="hljs-title function_">switchRadio</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Radio</span>, <span class="hljs-title class_">Battery</span> &#123; <span class="hljs-comment">// 实现多个接口</span><br>  <span class="hljs-title function_">switchRadio</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-title function_">checkBVatteryStatus</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CellPhone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RadioWithBattery</span> &#123;<br>  <span class="hljs-title function_">switchRadio</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-title function_">checkBVatteryStatus</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-enum-枚举"><a href="#5-enum-枚举" class="headerlink" title="5. enum 枚举"></a>5. enum 枚举</h1><p>定义与使用枚举类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// &quot;Up&quot;</span><br></code></pre></td></tr></table></figure><p>之所以枚举类可以被双向引用，是因为上面的代码被编译为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) &#123;<br>    <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Up&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Up&quot;</span>;<br>    <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Down&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Down&quot;</span>;<br>    <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Left&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Left&quot;</span>;<br>    <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Right&quot;</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">&quot;Right&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = &#123;&#125;));<br></code></pre></td></tr></table></figure><p>默认结构为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;Up&#x27;</span>,<br>  <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;Down&#x27;</span>,<br>  <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;Left&#x27;</span>,<br>  <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;Right&#x27;</span>,<br>  <span class="hljs-title class_">Up</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-title class_">Down</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-title class_">Left</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-title class_">Right</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，枚举类还可以设置默认值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&quot;UP&quot;</span>,<br>  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&quot;DOWN&quot;</span>,<br>  <span class="hljs-title class_">Left</span> = <span class="hljs-string">&quot;LEFT&quot;</span>,<br>  <span class="hljs-title class_">Right</span> = <span class="hljs-string">&quot;RIGHT&quot;</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>); <span class="hljs-comment">// &quot;UP&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Up&quot;</span>]); <span class="hljs-comment">// &quot;UP&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 应用于数据校验上</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;UP&quot;</span>;<br><span class="hljs-keyword">if</span> (result !== <span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;result error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h1><p>泛型可以看作是一个占位符，在使用的时候动态填入确定的类型值。</p><h2 id="6-1-泛型的简单示例"><a href="#6-1-泛型的简单示例" class="headerlink" title="6.1 泛型的简单示例"></a>6.1 泛型的简单示例</h2><p>如果我们定义一个方法，这个方法传入任意类型且返回同样的类型，这样我们可能会将方法定义为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">echo</span>(<span class="hljs-params">arg: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">any</span> &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-keyword">let</span> str = <span class="hljs-title function_">echo</span>(<span class="hljs-string">&quot;wulalala&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title function_">echo</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num); <span class="hljs-comment">// string  Bug:不符合预期的变量类型</span><br></code></pre></td></tr></table></figure><p>但是这样的话就缺少了类型校验，str 会被标为 any 类型，甚至还会出现 BUG。</p><p>为了避免这一情况，我们可以定义一个<strong>类型相同，但不对类型进行约束</strong>的变量类型 T ，我们将 T 称之为<strong>泛型</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> echo&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><span class="hljs-keyword">let</span> str = <span class="hljs-title function_">echo</span>(<span class="hljs-string">&quot;wulalala&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title function_">echo</span>(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// error: 不能将类型 &quot;123&quot; 分配给类型 &quot;number&quot; (Bug fixed)</span><br></code></pre></td></tr></table></figure><p>此外，泛型还可以用于元组中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> swap&lt;T, U&gt;(<span class="hljs-attr">tuple</span>: [T, U]): [U, T] &#123;<br>  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">swap</span>([<span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">123</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 123, &quot;string&quot;</span><br></code></pre></td></tr></table></figure><h2 id="6-2-泛型约束"><a href="#6-2-泛型约束" class="headerlink" title="6.2 泛型约束"></a>6.2 泛型约束</h2><p>假设现在我们有一个需求：传入一个具有 length 属性的对象，要求输出该对象的 length，同时返回与该对象同一类型的对象。</p><p>但是如果我们使用泛型的话，输出 length 时就会显示没有该属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> printLength&lt;T&gt;(<span class="hljs-attr">input</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">length</span>); <span class="hljs-comment">// error: 类型“T”上不存在属性“length”。</span><br>  <span class="hljs-keyword">return</span> input;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们可以使用泛型约束，来约束泛型 T 为一个数组类型：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- function printLength&lt;T&gt;(input: T): T &#123;</span><br><span class="hljs-addition">+ function printLength&lt;T&gt;(input: T[]): T[] &#123;</span><br>    console.log(input.length);<br>    return input;<br>  &#125;<br></code></pre></td></tr></table></figure><p>但是这样的话就失去了泛型原有的作用，用户只能在该方法中传入数组。string 类型同样有 length 属性，但是将 string 传入该方法中的话就会报错。因此更好的做法是去定义一个接口类型，接口类型中拥有 length 属性，string 和 array 都符合接口的规范，我们可以让定义的泛型继承自该接口，那么我们的需求就达到了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IinputWithLength</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> printLength&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IinputWithLength</span>&gt;(<span class="hljs-attr">input</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> input;<br>&#125;<br><br><span class="hljs-title function_">printLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-title function_">printLength</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-title function_">printLength</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> &#125;);<br><span class="hljs-title function_">printLength</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// error: 类型“123”的参数不能赋给类型“IinputWithLength”的参数</span><br></code></pre></td></tr></table></figure><h2 id="6-3-类和接口的泛型"><a href="#6-3-类和接口的泛型" class="headerlink" title="6.3 类和接口的泛型"></a>6.3 类和接口的泛型</h2><p>在前面我们再方法中使用了泛型，那么同样的我们可以在类中也使用泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> data = [];<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">item: T</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item);<br>  &#125;<br>  <span class="hljs-title function_">pop</span>(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;<span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// 在创建实例的时候要声明泛型的类型</span><br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">1.23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>));<br><br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;1.23&quot;</span>); <span class="hljs-comment">// error: 类型“&quot;1.23&quot;”的参数不能赋给类型“number”的参数。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>同样的接口也可以使用泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 用泛型定义接口对象</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">KeyPair</span>&lt;T, U&gt; &#123;<br>  <span class="hljs-attr">key</span>: T;<br>  <span class="hljs-attr">value</span>: U;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">kp1</span>: <span class="hljs-title class_">KeyPair</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; = &#123;<br>  <span class="hljs-attr">key</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;123&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 用泛型定义接口函数</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAdd</span>&lt;T&gt; &#123;<br>  (<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): T;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">IAdd</span>&lt;<span class="hljs-built_in">number</span>&gt; = add;<br></code></pre></td></tr></table></figure><p>数组也可以使用泛型来定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;2&quot;</span>];<br></code></pre></td></tr></table></figure><h1 id="7-类型别名与断言"><a href="#7-类型别名与断言" class="headerlink" title="7. 类型别名与断言"></a>7. 类型别名与断言</h1><h2 id="7-1-类型别名-Type-Aliases"><a href="#7-1-类型别名-Type-Aliases" class="headerlink" title="7.1 类型别名 Type Aliases"></a>7.1 类型别名 Type Aliases</h2><p>类型别名就是将联合类型或者是比较复杂的函数类型设置一个别名，可以提供给其他变量进行使用，对类型进行约束:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PluseType</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">PluseType</span> = sum;<br></code></pre></td></tr></table></figure><p>联合类型比较常用类型别名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NameResolver</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NameOrResolver</span> = <span class="hljs-built_in">string</span> | <span class="hljs-title class_">NameResolver</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">arg: NameOrResolver</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> arg;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">arg</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getName</span>(<span class="hljs-string">&quot;huahua&quot;</span>)); <span class="hljs-comment">// huahua</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-title function_">getName</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;huahua2&quot;</span>;<br>  &#125;)<br>); <span class="hljs-comment">// huahua2</span><br></code></pre></td></tr></table></figure><h2 id="7-2-类型断言-Type-Assertion"><a href="#7-2-类型断言-Type-Assertion" class="headerlink" title="7.2 类型断言 Type Assertion"></a>7.2 类型断言 Type Assertion</h2><p>可以使用 <code>as</code> 关键字对变量类型进行断言，我们可以将断言后的结果赋值到任意变量上，那么通过这个变量就可以使用我们断言的类型上所拥有的方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> str = input <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">if</span> (str.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-property">length</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">number</span> = input <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span>.<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，我们可以使用 <code>&lt;&gt;</code> 来更简洁的对变量进行断言并直接使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> ((&lt;<span class="hljs-built_in">string</span>&gt;input).<span class="hljs-property">length</span>) &#123;<br>  <span class="hljs-keyword">return</span> (&lt;<span class="hljs-built_in">string</span>&gt;input).<span class="hljs-property">length</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> (&lt;<span class="hljs-built_in">number</span>&gt;input).<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>两种方式都可以使用 <code>()</code> 包裹住后直接调用类型上的方法，或者将其赋值到一个变量上，通过变量调用类型上的方法。</p></blockquote><h1 id="8-声明文件"><a href="#8-声明文件" class="headerlink" title="8. 声明文件"></a>8. 声明文件</h1><p>假如我们要在项目中使用 jQuery 文件，那么可能会出现如下报错信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&quot;#id&quot;</span>); <span class="hljs-comment">// error: 找不到名称“jQuery”。</span><br></code></pre></td></tr></table></figure><p>此时我们需要 jQuery 的声明文件来帮助我们声明这个方法。我们可以使用关键字 <code>declear</code> 来声明一种方法，让项目可以借助 ts 的能力来对原来使用 js 构建的库文件使用类型断言：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">jQuery</span>: <span class="hljs-function">(<span class="hljs-params">selector: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br><span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&quot;#id&quot;</span>);<br></code></pre></td></tr></table></figure><p>通常我们可以使用 <code>d.ts</code> 文件作为专用的声明文件，这一文件将会被 ts 构建的时候被编译。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速指南</tag>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于BFC的特性以及如何利用BFC解决margin相关的问题</title>
    <link href="/2022/05/ddccc39c4ced.html"/>
    <url>/2022/05/ddccc39c4ced.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-何为BFC"><a href="#1-何为BFC" class="headerlink" title="1. 何为BFC?"></a>1. 何为BFC?</h1><blockquote><p>文章：<a href="https://juejin.im/post/5909db2fda2f60005d2093db#heading-8">https://juejin.im/post/5909db2fda2f60005d2093db#heading-8</a></p></blockquote><p>BFC概括：可以在心中记住这么一个概念———所谓的BFC就是css布局的一个概念，是一块区域，一个环境。</p><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p>FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。</p><p>常见的FC有<code>BFC</code>、<code>IFC</code>（行级格式化上下文），还有<code>GFC</code>（网格布局格式化上下文）和<code>FFC</code>（自适应格式化上下文），这里就不再展开了。</p><h1 id="2-触发BFC的方式"><a href="#2-触发BFC的方式" class="headerlink" title="2. 触发BFC的方式"></a>2. 触发BFC的方式</h1><p>满足下列条件之一就可触发BFC</p><ol><li>根元素，即HTML元素</li><li>float的值不为none</li><li>overflow的值不为visible</li><li>display的值为inline-block、table-cell、table-caption</li><li>position的值为absolute或fixed</li></ol><h1 id="3-布局规则"><a href="#3-布局规则" class="headerlink" title="3. 布局规则"></a>3. 布局规则</h1><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li></ol><h1 id="4-BFC作用"><a href="#4-BFC作用" class="headerlink" title="4. BFC作用"></a>4. BFC作用</h1><ol><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li><li>可以包含浮动元素——清除内部浮动</li><li><del>分属于不同的BFC时可以阻止margin重叠</del></li></ol><h1 id="5-BFC解决margin问题"><a href="#5-BFC解决margin问题" class="headerlink" title="5. BFC解决margin问题"></a>5. BFC解决margin问题</h1><p>使用margin存在两种问题，一种是穿透问题，一种是折叠问题。</p><h2 id="5-1-穿透问题"><a href="#5-1-穿透问题" class="headerlink" title="5.1 穿透问题"></a>5.1 穿透问题</h2><p>穿透问题即为子级元素的垂直方向margin会穿透父级元素，导致父级元素发生位移，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><span class="hljs-selector-class">.inner</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/22/tuvfZTjLIEYdoCn.png"></p><p><img src="https://s2.loli.net/2023/04/22/ruWUjJ4Em1bGCxq.png"></p><h2 id="5-2-margin折叠问题"><a href="#5-2-margin折叠问题" class="headerlink" title="5.2 margin折叠问题"></a>5.2 margin折叠问题</h2><p>margin折叠问题即为同属一个BFC中的垂直元素的垂直margin值在页面计算时发生了折叠而并不会累加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/22/RNsJpWG267yZtCl.png"></p><h2 id="5-3-两种问题应该如何解决"><a href="#5-3-两种问题应该如何解决" class="headerlink" title="5.3 两种问题应该如何解决"></a>5.3 两种问题应该如何解决</h2><h3 id="5-3-1-解决margin溢出"><a href="#5-3-1-解决margin溢出" class="headerlink" title="5.3.1 解决margin溢出"></a>5.3.1 解决margin溢出</h3><p>解决margin穿透问题可以使用BFC的特性来将父级元素设置为一个独立的BFC，子级元素的margin值就不会溢出父级，而是将父级作为一个独立区域去计算margin值，我们这里用 <code>overflow: hidden</code> 来触发父级的BFC：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.inner</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/22/TvxG7Yc5yUhqMnm.png"></p><h3 id="5-3-2-解决margin重叠"><a href="#5-3-2-解决margin重叠" class="headerlink" title="5.3.2 解决margin重叠"></a>5.3.2 解决margin重叠</h3><p>网上很多文章都说可以使用BFC特性来解决margin折叠其实是错误的，如果我们用 <code>overflow: hidden</code> 将两个div设置为不同的两个BFC区域，那么我们会发现该重叠的还是会重叠。</p><p>查阅相关资料显示只有以下一种方式可以使元素上下margin不折叠：</p><blockquote><p>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） </p><p>作者：丁小倪 链接：<a href="https://www.zhihu.com/question/19823139/answer/13610574">https://www.zhihu.com/question/19823139/answer/13610574</a> 来源：知乎</p></blockquote><p>之所以很多文章生成BFC可以解决垂直margin重叠的问题，是因为浮动元素、inline-block 元素、绝对定位元素都在触发了BFC的同时解决了重叠问题。也就是说可以解决垂直margin重叠问题的方法都可以让元素具有BFC特性，但是让元素具有BFC特性不一定能够解决垂直margin重叠的问题。</p><p>所以如果我们需要解决margin重叠问题，那就将元素设置为浮动元素，或者将其设置为 inline-block 元素，或者使用绝对定位，但这些都会对元素的样式产生副作用，我们采用将元素设置为 inline-block 元素的方法来演示如何解决这一问题（注意 <code>inline-block</code> 元素对空格敏感，会导致两个div之间出现空隙，具体的解决方法看：<a href="https://segmentfault.com/a/1190000010934928">https://segmentfault.com/a/1190000010934928</a> ）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/22/83bFj5LdXeK4vND.png"></p><p>其实如果利用BFC特性也能实现去掉上下margin的效果，只不过原理上还是利用BFC阻止margin溢出，我们可以将两个div套上一个BFC的外壳，这样两个BFC的内部元素就不会互相影响了：</p><blockquote><p>作者：陈厚毅 链接：<a href="https://www.zhihu.com/question/19823139/answer/50075651">https://www.zhihu.com/question/19823139/answer/50075651</a> 来源：知乎</p></blockquote><p><img src="https://s2.loli.net/2023/04/22/oBiXgMWQ5RcH2AO.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>BFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3新特性初探与对比</title>
    <link href="/2022/05/23f515250f71.html"/>
    <url>/2022/05/23f515250f71.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Vue3-新特性"><a href="#1-Vue3-新特性" class="headerlink" title="1. Vue3 新特性"></a>1. Vue3 新特性</h1><p>Vue3 的一些特性：</p><ul><li>渐进式开发，兼容 Vue2 的特性</li><li>性能的提升<ul><li>打包减少 41%</li><li>初次渲染快 55%</li><li>更新快 133%</li><li>内存占用 54%</li></ul></li><li>Composition API 合集，解决组件开发问题</li><li>新的 API 的加入<ul><li>Teleport 瞬移组件</li><li>Suspense 解决异步组件加载问题</li></ul></li><li>更好的 Typescript 支持</li></ul><h1 id="2-脚手架工具"><a href="#2-脚手架工具" class="headerlink" title="2 脚手架工具"></a>2 脚手架工具</h1><p>使用 vue-cli 创建项目后，vscode 的 prettier 可能与 eslint 存在冲突，需要手动设置。具体表现在使用 ctrl+shift+f 进行格式化时，会采用全局 prettier 规则，而在 ctrl+s 时会采用项目的 eslint 规则，对文件进行格式化。</p><p>在全局的 prettier 规则中 <code>trailingComma</code> 默认设置为 <code>es5</code> 即在多行的数组、对象的每一项的末尾都添加 <code>,</code>。然而在项目内的 eslint 读取的 @vue&#x2F;prettier 插件规则中，该项被设置为 <code>none</code>，因此需要手动将规则设置为与全局的规则一致，具体修改方案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs diff">  // .eslintrc.js<br>  module.exports = &#123;<br>    root: true,<br>    env: &#123;<br>      node: true,<br>    &#125;,<br>    extends: [<br>      &quot;plugin:vue/vue3-essential&quot;,<br>      // ... ...<br>    ],<br>    parserOptions: &#123;<br>      ecmaVersion: 2020,<br>    &#125;,<br>    rules: &#123;<br>      &quot;no-console&quot;: process.env.NODE_ENV <span class="hljs-comment">=== &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,</span><br>      &quot;no-debugger&quot;: process.env.NODE_ENV <span class="hljs-comment">=== &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,</span><br><span class="hljs-addition">+     &quot;prettier/prettier&quot;: [&quot;warn&quot;, &#123; trailingComma: &quot;es5&quot; &#125;],</span><br>    &#125;,<br>  &#125;;<br></code></pre></td></tr></table></figure><h1 id="3-创建一个-Vue-实例"><a href="#3-创建一个-Vue-实例" class="headerlink" title="3. 创建一个 Vue 实例"></a>3. 创建一个 Vue 实例</h1><p>在 Vue3 中，创建一个实例与 Vue2 有着很大的差别。在 Vue2 中创建实例我们通常使用 new 关键字，来直接创建一个 Vue 实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然而在 Vue3 中，引入了新的 api <code>Vue.createApp()</code> 来创建 Vue 实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span><br>  Counter: &#123;&#123; counter &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span> = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">Counter</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#counter&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="4-setup"><a href="#4-setup" class="headerlink" title="4. setup"></a>4. setup</h1><blockquote><p><a href="https://vue3js.cn/docs/zh/api/composition-api.html#setup">https://vue3js.cn/docs/zh/api/composition-api.html#setup</a></p></blockquote><p>一个组件选项，在创建组件<strong>之前</strong>执行，一旦 <code>props</code> 被解析，并作为组合式 API 的入口点</p><h2 id="4-1-ref"><a href="#4-1-ref" class="headerlink" title="4.1 ref"></a>4.1 ref</h2><p>在创建 Vue3 组件实例时新增了一个 <code>setup</code> 属性，该属性应当传入一个方法，通过该属性，可以简化我们之前需要同时编写 <code>data</code> 与 <code>methods</code> 属性来执行某些操作。</p><p>同时也新增了 <a href="https://vue3js.cn/docs/zh/api/refs-api.html#ref">ref</a> 方法，接受一个内部值并返回一个响应式且可变的 ref 对象。创建的 ref 对象必须使用 <code>refObj.value</code> 的方式去写入值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;欢迎光临红浪漫洗浴中心&lt;/h2&gt;<br>    &lt;div&gt;请选择一位美女为你服务&lt;/div&gt;<br>  &lt;/div&gt;<br>  &lt;div&gt;<br>    &lt;button<br>      v-for=&quot;(item, index) in girls&quot;<br>      v-bind:key=&quot;index&quot;<br>      @click=&quot;selectGirlFun(index)&quot;<br>    &gt;<br>      &#123;&#123; index &#125;&#125; : &#123;&#123; item &#125;&#125;<br>    &lt;/button&gt;<br>  &lt;/div&gt;<br>  &lt;div&gt;你选择了【&#123;&#123; selectGirl &#125;&#125;】为你服务&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import &#123; defineComponent, ref &#125; from &quot;vue&quot;;<br>export default defineComponent(&#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>    const girls = ref([&quot;大脚&quot;, &quot;刘英&quot;, &quot;晓红&quot;]);<br>    const selectGirl = ref(&quot;&quot;);<br>    <br>    // 由于函数无需转为 “响应式” 对象，因此无需使用 ref 进行转化<br>    const selectGirlFun = (index: number) =&gt; &#123;<br>      selectGirl.value = girls.value[index];<br>    &#125;;<br><br>    return &#123;<br>      girls,<br>      selectGirl,<br>      selectGirlFun,<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>从这里可以看出 vue3 与 ReactHook 有一定的相似之处，<code>ref</code> 创建值相当于 ReactHook 中使用 <code>useState</code> 创建 State 对象；<br>同时在 <code>setup</code> 中直接编写的函数方法可以在 template 中直接调用，也与 ReactHook 中写入编写的方法可以直接在 jsx 中调用有相似之处。</p></blockquote><h2 id="4-2-reactive"><a href="#4-2-reactive" class="headerlink" title="4.2 reactive"></a>4.2 reactive</h2><p>在上面的代码中，每次创建值都需要使用 <code>ref</code> 同时写入值时也需要使用 <code>refObj.value</code> 来改写；为了避免上面的繁琐操作，可以使用 <a href="https://vue3js.cn/docs/zh/api/basic-reactivity.html#reactive">reactive</a> 来简化操作。 </p><p><code>reactive</code> 可以返回对象的<strong>响应式</strong>副本，可以简单理解为传入的属性都会被转化为“响应式”的，相当于将传入的所有属性都使用 <code>ref()</code> 去生成一个响应式且可变的 ref 对象（待商榷）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> girls = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>]);<br><span class="hljs-keyword">const</span> selectGirl = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// selectGirlFun 可以直接在 template 中被绑定调用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectGirlFun</span> = (<span class="hljs-params">index: number</span>) =&gt; &#123;<br>  selectGirl.<span class="hljs-property">value</span> = girls.<span class="hljs-property">value</span>[index];<br>&#125;;<br><br><span class="hljs-keyword">return</span> &#123;<br>  girls,<br>  selectGirl,<br>  selectGirlFun,<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">girls</span>: [<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>],<br>  <span class="hljs-attr">selectGirl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">selectGirlFun</span>: <span class="hljs-function">(<span class="hljs-params">index: number</span>) =&gt;</span> &#123;<br>    data.<span class="hljs-property">selectGirl</span> = data.<span class="hljs-property">girls</span>[index];<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>但是当我们在 <code>setup</code> 中返回可响应数据对象时，如果使用展开运算符，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> &#123;<br>  ...data<br>&#125;<br></code></pre></td></tr></table></figure><p>那么得到的数据是将是一组不可变的，原因是因为 <code>reactive</code> 返回的是一个响应式对象，而展运算符会破坏这种结构。</p><p>这时可以使用 <a href="https://vue3js.cn/docs/zh/api/refs-api.html#torefs">toRefs</a>。<code>toRefs</code> 可以用来为源响应式对象上的 property 性创建一个 ref，然后可以将 ref 传递出去，从而保持对其源 property 的响应式连接。</p><p>借助这个特性，我们就可以获取一个 ToRefs 对象，这个对象的所有 property 都连接到了原始对象，因此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-comment">// ... some property</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br><br><span class="hljs-keyword">return</span> &#123;<br>  ...refData<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-comment">// ... some property</span><br>&#125;);<br><br><span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><h1 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5 生命周期"></a>5 生命周期</h1><h2 id="5-1-在-setup-中使用生命周期"><a href="#5-1-在-setup-中使用生命周期" class="headerlink" title="5.1 在 setup 中使用生命周期"></a>5.1 在 setup 中使用生命周期</h2><p>vue2 中有以下生命周期：</p><p><img src="https://cn.vuejs.org/images/lifecycle.png"></p><p>在 vue3 中，如果使用了 <code>setup()</code>，那么 <code>setup()</code> 会在 <code>beforeCreate</code> 与 <code>created</code> 之前执行。</p><p>如果要在 <code>setup()</code> 中使用生命周期可以从 vue 中导出 <code>onXXX</code> 的方法，在 <code>setup()</code> 中调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onBeforeMount, onMounted, reactive, toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Demo02&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-comment">// ... ...</span><br>    &#125;);<br><br>    <span class="hljs-comment">// Life Event</span><br>    <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onBeforeMount&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-2-Vue3-的生命周期执行顺序"><a href="#5-2-Vue3-的生命周期执行顺序" class="headerlink" title="5.2 Vue3 的生命周期执行顺序"></a>5.2 Vue3 的生命周期执行顺序</h2><p>在 Vue3 中，Vue2 老的生命周期钩子函数仍然可以使用，但是他们都稍晚于 Vue2 中在 <code>setup()</code> 中执行的生命周期钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Demo02&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setup()&quot;</span>);<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-comment">// ... ...</span><br>    &#125;);<br><br>    <span class="hljs-comment">// Life Event</span><br>    <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onBeforeMount&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onMounted&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;,<br>  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeCreate&quot;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeMount&quot;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;mounted&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br>beforeCreate<br>created<br>onBeforeMount<br>beforeMount<br>onMounted<br>mounted<br></code></pre></td></tr></table></figure><blockquote><p>Vue3 中没有 <code>onBeforeCreate()</code> 与 <code>beforeCreated</code> 生命周期钩子</p></blockquote><h2 id="5-3-新增的生命周期函数"><a href="#5-3-新增的生命周期函数" class="headerlink" title="5.3 新增的生命周期函数"></a>5.3 新增的生命周期函数</h2><p>Vue3 新增了 <code>onRenderTracked</code> 与 <code>onRenderTriggered</code> 生命周期钩子，可以用于调试。</p><p><code>onRenderTracked()</code> 状态跟踪函数，会跟踪每个值的变动，其内部传递的回调函数存在一个 <code>event</code> 参数，可以获取到监听结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">girls</span>: [<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>],<br>    <span class="hljs-attr">selectGirl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">selectGirlFun</span>: <span class="hljs-function">(<span class="hljs-params">index: number</span>) =&gt;</span> &#123;<br>      data.<span class="hljs-property">selectGirl</span> = data.<span class="hljs-property">girls</span>[index];<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br><br>  <span class="hljs-title function_">onRenderTracked</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...refData,<br>  &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/21/wLlZGVzKJd96q4n.png"></p><p><code>onRenderTriggered()</code> 状态触发函数，当组件内的值改变时，会触发该函数，对外传递的 event 会显示改变值的索引以及 oldValue 与 newValue：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">girls</span>: [<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>],<br>    <span class="hljs-attr">selectGirl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">selectGirlFun</span>: <span class="hljs-function">(<span class="hljs-params">index: number</span>) =&gt;</span> &#123;<br>      data.<span class="hljs-property">selectGirl</span> = data.<span class="hljs-property">girls</span>[index];<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br><br>  <span class="hljs-comment">// Life Circle Hook</span><br>  <span class="hljs-title function_">onRenderTriggered</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...refData,<br>  &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p>当 selectGirl 发生改变时：</p><p><img src="https://i.loli.net/2021/03/21/Xy72tzMPka6rV9o.png"></p><h1 id="6-Watch-监听"><a href="#6-Watch-监听" class="headerlink" title="6. Watch 监听"></a>6. Watch 监听</h1><p>在 Vue3 中，<code>setup()</code> 函数内可以使用 <code>watch()</code> 方法来设置监听：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Demo02&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> overText = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;红浪漫&quot;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">overAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      overText.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;点餐完成|&quot;</span> + overText.<span class="hljs-property">value</span>;<br>    &#125;;<br><br>    <span class="hljs-title function_">watch</span>(overText, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`new ----&gt; <span class="hljs-subst">$&#123;newValue&#125;</span>`</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`old ----&gt; <span class="hljs-subst">$&#123;oldValue&#125;</span>`</span>);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = newValue;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      overText,<br>      overAction,<br>    &#125;;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>watch</code> 方法的第一个参数可以传入一个 Ref 对象，也可以传入一个以来数组。但是要注意的是，<strong>监听的对象只能是 getter&#x2F;effect 函数、ref 对象、reactive 对象或者一个数组</strong>。如果我们想要监听 <code>reactive</code> 中转化的值的话，由于其进行过转化，取值时其就是一个值类型，因此必须将其转化为一个 “getter 函数”，如 <code>() =&gt; variable</code>，举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">girls</span>: [<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>],<br>    <span class="hljs-attr">selectGirl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br>  <span class="hljs-keyword">const</span> overText = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;红浪漫&quot;</span>);<br><br>  <span class="hljs-comment">// ... ...</span><br><br>  <span class="hljs-comment">// 监听 overText 以及 selectGirl </span><br>  <span class="hljs-comment">// overText =&gt; Ref&lt;string&gt; | data.selectGirl =&gt; string</span><br>  <span class="hljs-title function_">watch</span>([overText, <span class="hljs-function">() =&gt;</span> data.<span class="hljs-property">selectGirl</span>], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newValue: &quot;</span>, newValue);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;oldValue: &quot;</span>, oldValue);<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = newValue[<span class="hljs-number">0</span>];<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...refData,<br>    overText,<br>    overAction,<br>  &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p>Vue2 的 watch 用法同样适用于 Vue3 且无需任何特殊处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Demo02&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DataProps</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-attr">girls</span>: [<span class="hljs-string">&quot;大脚&quot;</span>, <span class="hljs-string">&quot;刘英&quot;</span>, <span class="hljs-string">&quot;晓红&quot;</span>],<br>      <span class="hljs-attr">selectGirl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;);<br>    <span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br>    <span class="hljs-keyword">const</span> overText = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;红浪漫&quot;</span>);<br><br>    <span class="hljs-title function_">watch</span>([overText, <span class="hljs-function">() =&gt;</span> data.<span class="hljs-property">selectGirl</span>], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newValue: &quot;</span>, newValue);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;oldValue: &quot;</span>, oldValue);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = newValue[<span class="hljs-number">0</span>];<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...refData,<br>      overText,<br>    &#125;;<br>  &#125;,<br><br>  <span class="hljs-comment">// Vue2 监听器可以正常使用</span><br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">overText</span>(<span class="hljs-params">newVal: any</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newVal: &quot;</span>, newVal);<br>    &#125;,<br>    <span class="hljs-title function_">selectGirl</span>(<span class="hljs-params">newVal: any</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newVal: &quot;</span>, newVal);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="6-自定义-hook"><a href="#6-自定义-hook" class="headerlink" title="6. 自定义 hook"></a>6. 自定义 hook</h1><p>与 React 相似的，Vue3 中也可以使用自定义 Hook，将逻辑代码剥离出组件。</p><p>以下的示例是演示如何抽离出一个获取当前时间的组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// useNowTime.ts</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> nowTime = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;00:00:00&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getNowTime</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-keyword">const</span> hour = now.<span class="hljs-title function_">getHours</span>();<br>  <span class="hljs-keyword">const</span> min = now.<span class="hljs-title function_">getMinutes</span>();<br>  <span class="hljs-keyword">const</span> sec = now.<span class="hljs-title function_">getSeconds</span>();<br>  nowTime.<span class="hljs-property">value</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;hour&#125;</span>:<span class="hljs-subst">$&#123;min&#125;</span>:<span class="hljs-subst">$&#123;sec&#125;</span>`</span>;<br>  <span class="hljs-built_in">setTimeout</span>(getNowTime, <span class="hljs-number">1000</span>);<br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123; nowTime, getNowTime &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">// Demo03.vue<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;div&gt;&#123;&#123; nowTime &#125;&#125;&lt;/div&gt;<br>    &lt;button @click=&quot;getNowTime&quot;&gt;获取时间&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import &#123; nowTime, getNowTime &#125; from &quot;./hooks/useNowTime&quot;;<br><br>export default &#123;<br>  name: &quot;Demo03&quot;,<br>  setup() &#123;<br>    return &#123;<br>      nowTime,<br>      getNowTime,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/23/OhYQdLwMk3iTl6K.png"></p><p>当然，我们完全可以模仿 react hook 的写法，将 useHook 文件导出一个方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// useNowTime.ts</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useNowTime</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> nowTime = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;00:00:00&quot;</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getNowTime</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> hour = now.<span class="hljs-title function_">getHours</span>();<br>    <span class="hljs-keyword">const</span> min = now.<span class="hljs-title function_">getMinutes</span>();<br>    <span class="hljs-keyword">const</span> sec = now.<span class="hljs-title function_">getSeconds</span>();<br>    nowTime.<span class="hljs-property">value</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;hour&#125;</span>:<span class="hljs-subst">$&#123;min&#125;</span>:<span class="hljs-subst">$&#123;sec&#125;</span>`</span>;<br>    <span class="hljs-built_in">setTimeout</span>(getNowTime, <span class="hljs-number">1000</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123; nowTime, getNowTime &#125;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useNowTime;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">// Demo03.vue<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;div&gt;&#123;&#123; nowTime &#125;&#125;&lt;/div&gt;<br>    &lt;button @click=&quot;getNowTime&quot;&gt;获取时间&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import useNowTime from &quot;./hooks/useNowTime&quot;;<br><br>export default &#123;<br>  name: &quot;Demo03&quot;,<br>  setup() &#123;<br>    const &#123; nowTime, getNowTime &#125; = useNowTime();<br><br>    return &#123;<br>      nowTime,<br>      getNowTime,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="7-Teleport"><a href="#7-Teleport" class="headerlink" title="7. Teleport"></a>7. Teleport</h1><p>Teleport 被称为瞬间移动组件，是 Vue3 新增的组件。它可以更便捷的将组件的 Dom 节点挂载到目标节点中，这对于我们写一些全局组件非常有用，比如 Alert、Modal、Notification 组件。</p><p>以 Modal 组件为例，我们会将 Modal 组件的 Wrapper 设置为相对定位，让其覆盖整个屏幕，写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">// Modal.vue<br>&lt;template&gt;<br>  &lt;div class=&quot;modal&quot;&gt;<br>    &lt;div class=&quot;modal-content center&quot;&gt;<br>      &lt;h2&gt;zpangxie.top&lt;/h2&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>export default &#123;<br>  name: &quot;&quot;,<br>  setup() &#123;<br>    return &#123;&#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.modal &#123;<br>  width: 100%;<br>  height: 100%;<br>  position: absolute;<br>  background-color: rgba(0, 0, 0, 0.5);<br>  left: 0;<br>  top: 0;<br>  .center &#123;<br>    width: 200px;<br>    height: 200px;<br>    border: 2px solid #000000;<br>    background: #ffffff;<br>    left: 50%;<br>    top: 50%;<br>    transform: translate(-50%, -50%);<br>    position: absolute;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>然而当页面逐渐复杂，我们在页面中使用这个组件时，组件会被挂载到调用的位置时，如果父级 Dom 节点的样式设置了定位，那么就会对 Modal 组件的定位产生影响，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;Demo05&quot;&gt;<br>    &lt;Modal /&gt;<br>    &lt;h1&gt;Demo05&lt;/h1&gt;<br>    &lt;p&gt;<br>      Vue 鼓励我们通过将 UI 和相关行为封装到组件中来构建<br>      UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。<br>    &lt;/p&gt;<br>    &lt;p&gt;<br>      然而，有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到<br>      DOM 中 Vue app 之外的其他位置。<br>    &lt;/p&gt;<br>    &lt;p&gt;<br>      一个常见的场景是创建一个包含全屏模式的组件。在大多数情况下，你希望模态的逻辑存在于组件中，但是模态的定位很快就很难通过<br>      CSS 来解决，或者需要更改组件组合。<br>    &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import Modal from &quot;./components/Modal.vue&quot;;<br><br>export default &#123;<br>  name: &quot;Demo05&quot;,<br>  components: &#123;<br>    Modal,<br>  &#125;,<br>  setup() &#123;<br>    return &#123;&#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>#Demo05 &#123;<br>  position: relative;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>此时页面会表现为：</p><p><img src="https://i.loli.net/2021/03/27/5vptRrBD964hTZw.png"></p><p>Dom 节点结构为：</p><p><img src="https://i.loli.net/2021/03/27/NwRWSunJ9mlc37B.png"></p><p>要解决这个问题，我们就必须要想办法把 Modal 组件移出去。在 Vue2 中，我们可以通过<a href="https://cn.vuejs.org/v2/guide/render-function.html">渲染函数</a>来将渲染内容指定渲染在 HTML 的任意目标位置，其核心是在生成虚拟 DOM 后对其进行 <code>targetDom.appendChild(virtualDom)</code> 操作。</p><p>在 Vue3 中，我们可以直接使用 <code>Teleport</code> 组件来将组件渲染到页面的指定位置，因此我们只需要更改我们的 Modal 组件为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;teleport to=&quot;body&quot;&gt;<br>    &lt;div class=&quot;modal&quot;&gt;<br>      &lt;div class=&quot;modal-content center&quot;&gt;<br>        &lt;h2&gt;zpangxie.top&lt;/h2&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/teleport&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>此时 Modal 组件表现完全正常，因为其直接挂载到了 body 节点中：</p><p><img src="https://i.loli.net/2021/03/27/SRDH235GbPurwn7.png"></p><h1 id="8-Suspense"><a href="#8-Suspense" class="headerlink" title="8. Suspense"></a>8. Suspense</h1><p><code>Suspense</code> 是 vue3 中新增的组件，类似于 <code>keep-alive</code> 不需要任何的引入，可以直接进行使用。自带两个 <code>slot</code> 分别为 <code>default、fallback</code>。顾名思义，当要加载的组件不满足状态时,<code>Suspense</code> 将回退到 <code>fallback</code>状态一直到加载的组件满足条件，才会进行渲染。</p><p>在官方示例中，<code>Suspense</code> 与 <a href="https://vue3js.cn/docs/zh/guide/component-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件（defineAsyncComponent）</a> 配合使用的。当异步组件加载时可以为用户显示一个 loading 界面，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;Suspense&gt;<br>      &lt;template #default&gt;<br>        &lt;AsyncComponent /&gt;<br>      &lt;/template&gt;<br>      &lt;template #fallback&gt;<br>        &lt;h2&gt;Loading... ...&lt;/h2&gt;<br>      &lt;/template&gt;<br>    &lt;/Suspense&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>其实除了使用 <code>defineAsyncComponent</code> 声明的异步组件外，组件的 <code>setup()</code> 函数如果是一个 async 函数的话，该组件也属于一个异步组件，也可以使用 <code>Suspense</code> 来显示组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">// AsyncShow.vue<br>// 获取图片的异步组件<br>&lt;template&gt;<br>  &lt;div class=&quot;async-show&quot;&gt;<br>    &lt;h2&gt;Result: &#123;&#123; result &#125;&#125;&lt;/h2&gt;<br>    &lt;img :src=&quot;result &amp;&amp; result.imgurl&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import &#123; defineComponent &#125; from &quot;vue&quot;;<br>import axios from &quot;axios&quot;;<br><br>export default defineComponent(&#123;<br>  name: &quot;AsyncShow&quot;,<br>  async setup() &#123;<br>    const rawData = await axios.get(&quot;/api/api.php?return=json&quot;);<br>    return &#123;<br>      result: rawData.data,<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">// index.vue<br>// 引入 AsyncShow.vue<br>&lt;template&gt;<br>  &lt;div id=&quot;Demo06&quot;&gt;<br>    &lt;h1&gt;Demo06&lt;/h1&gt;<br>    &lt;Suspense&gt;<br>      &lt;template #default&gt;<br>        &lt;AsyncShow /&gt;<br>      &lt;/template&gt;<br>      &lt;template #fallback&gt;<br>        &lt;h2&gt;Loading... ...&lt;/h2&gt;<br>      &lt;/template&gt;<br>    &lt;/Suspense&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>如果异步组件加载失败，可以使用 <code>onErrorCaptured</code> 来捕获：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">// index.vue<br>&lt;script lang=&quot;ts&quot;&gt;<br>import &#123; onErrorCaptured &#125; from &quot;vue&quot;;<br>export default &#123;<br>  // ... ...<br>  setup() &#123;<br>    onErrorCaptured(error =&gt; &#123;<br>      // 捕获异常<br>      console.log(error);<br>      return true;<br>    &#125;);<br><br>    return &#123;&#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript数据结构：链表</title>
    <link href="/2022/05/2215491ea1f1.html"/>
    <url>/2022/05/2215491ea1f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1. 概论"></a>1. 概论</h1><h2 id="1-1-链表与数组的区别"><a href="#1-1-链表与数组的区别" class="headerlink" title="1.1 链表与数组的区别"></a>1.1 链表与数组的区别</h2><p>存储多个元素来说，链表与数组都是很好的选择。Javascript 也内置的数组对象（小知识：Javascript 第一个版本中没有数组对象），并且定义了很多的操作方法。<strong>但是数组也有很多的不足，对于数组来说，从数组的起点或中间插入或移除项目的成本很高，因为要移动元素</strong>。然而对于链表而言，插入元素或者删除元素只需要移动链的指向即可，成本相对较低。然而但对于单纯的访问元素来说，数组可以直接通过索引坐标来访问，而链表要想访问一个数组则需要从头结点（Head）开始访问到最后。</p><h2 id="1-2-链表的结构"><a href="#1-2-链表的结构" class="headerlink" title="1.2 链表的结构"></a>1.2 链表的结构</h2><p>链表通常由一个 Head 节点开始，链中的每个节点都有一个 value 存放节点的值，以及一个 next 指针来指向下一个节点，直到最后一个节点的 next 指向 null。</p><p><img src="http://img.cdn.esunr.xyz/markdown/20200514172551.png"></p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>链表在 Javascript 中并没有一个内置的实现，因此需要我们手动实现。</p><h2 id="2-1-节点的构建"><a href="#2-1-节点的构建" class="headerlink" title="2.1 节点的构建"></a>2.1 节点的构建</h2><p>节点是链表中的基本单位，一个节点包含当前节点的值，以及一个 next 指针指向下一个节点对象，我们可以构建为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>我们就构建好了一个基本节点：</p><p><img src="http://img.cdn.esunr.xyz/markdown/20200514173244.png"></p><h2 id="2-2-链表结构的构建"><a href="#2-2-链表结构的构建" class="headerlink" title="2.2 链表结构的构建"></a>2.2 链表结构的构建</h2><p>虽然我们已经构建出了链表节点的结构，但是我们还未对整个链表的整体结构进行一个定义。一个链表的整体结构是由一个 Head 节点出发的，因此 Head 节点是链表实例上的一个属性，同时节点数也是一个链表的属性，此外链表上还拥有各种各样的方法，以便于我们去打印链表、添加节点、删除节点、查找节点。</p><p>因此我们可以构建出一下一个链表的基本结构，随后再对链表的内置方法进行定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/** 具体实现 */</span> &#125;<br>  <br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">value</span>) &#123; <span class="hljs-comment">/** 具体实现 */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-打印链表"><a href="#2-3-打印链表" class="headerlink" title="2.3 打印链表"></a>2.3 打印链表</h2><p>打印链表需要从链表头部开始打印，依次向后重复取值，指导取值为 null 时停止取值</p><p><img src="http://img.cdn.esunr.xyz/markdown/20200514174717.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>    cur.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span><br>      ? (res += cur.<span class="hljs-property">value</span>)<br>      : (res += cur.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;=&gt;&quot;</span>);<br>    cur = cur.<span class="hljs-property">next</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-向链表尾部添加元素"><a href="#2-4-向链表尾部添加元素" class="headerlink" title="2.4 向链表尾部添加元素"></a>2.4 向链表尾部添加元素</h2><p>为链表添加节点分两种情况：</p><ul><li>如果链表中没有节点（<code>this.head === null</code>），则新增节点作为 head</li><li>如果链表中有节点，则在链表最后一位添加节点</li></ul><p><img src="http://img.cdn.esunr.xyz/markdown/20200514175453.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">push</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 新结点</span><br>  <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>  <span class="hljs-comment">// 如果是头节点为空就将新节点放到头结点上</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>  &#125;<br>  <span class="hljs-comment">// 否则将新节点放到链表的末尾</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>      cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    cur.<span class="hljs-property">next</span> = newNode;<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-删除节点"><a href="#2-5-删除节点" class="headerlink" title="2.5 删除节点"></a>2.5 删除节点</h2><p>删除节点也分两种情况：</p><ul><li>如果是移除第一项，就将链表的 head 转移给第二个节点</li><li>如果移除的不是第一项，就找到目标索引对应的节点，将节点的上一个节点的 next 指向，改为下一个节点上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">removeAt</span>(<span class="hljs-params">index</span>) &#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;索引值不存在&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果是移除第一项，就将链表的 head 转移给第二个节点</span><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果移除的不是第一项，就找到目标索引对应的节点，</span><br>  <span class="hljs-comment">// 将节点的上一个节点的 next 指向，改为下一个节点上</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">let</span> prev;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>      prev = cur;<br>      cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-comment">// 更改目标节点上一个节点的指向</span><br>    prev.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canvas快速使用教程</title>
    <link href="/2022/05/170d914aa258.html"/>
    <url>/2022/05/170d914aa258.html</url>
    
    <content type="html"><![CDATA[<h1 id="Canvas概述"><a href="#Canvas概述" class="headerlink" title="Canvas概述"></a>Canvas概述</h1><h2 id="1-与Flash的区别"><a href="#1-与Flash的区别" class="headerlink" title="1. 与Flash的区别"></a>1. 与Flash的区别</h2><p>Canvas 和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做 Action Script 也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。</p><h2 id="2-创建Canvas画布标签"><a href="#2-创建Canvas画布标签" class="headerlink" title="2. 创建Canvas画布标签"></a>2. 创建Canvas画布标签</h2><p>显示默认提醒消息：如果浏览器不支持Canvas，Canvas会被默认渲染为普通标签显示文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200px&quot;</span>&gt;</span>对不起您的浏览器不支持画布！<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：Canvas有一个默认宽高，大概为<code>300 x 150</code>，如果我们用CSS样式去设置Canvas的宽高，会导致画布扭曲，必须在Canvas标签内部，以属性的方式去添加宽高值。</p><h2 id="3-用Javascript操作2D画布"><a href="#3-用Javascript操作2D画布" class="headerlink" title="3. 用Javascript操作2D画布"></a>3. 用Javascript操作2D画布</h2><p>首先要获取到画布对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span>&gt;</span>对不起您的浏览器不支持画布！<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> myCanvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#myCanvas&quot;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取到画布后，使用画布对象上的 <code>.getContext()</code> 方法新建一个画布</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置上下文，就相当于打开ps之后让你新建画布</span><br><span class="hljs-keyword">var</span> ctx = myCanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br></code></pre></td></tr></table></figure><p>之后就可以对画布进行详细的样式操作（要在绘制动作前设置样式），如设置背景颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;pink&quot;</span><br></code></pre></td></tr></table></figure><p>设置完样式之后就可以进行绘制操作，如绘制成一个矩形（Rect）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>)<br><span class="hljs-comment">// fillRect方法中的参数为设置绘制点的坐标，单位为px</span><br></code></pre></td></tr></table></figure><h2 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h2><p>方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fill<span class="hljs-constructor">Rect(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">d</span>)</span> 绘制一个填充矩形，abcd分别为四个坐标<br></code></pre></td></tr></table></figure><p>属性：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fillStyle</span> 设置填充颜色；<br></code></pre></td></tr></table></figure><h1 id="笔触、填充"><a href="#笔触、填充" class="headerlink" title="笔触、填充"></a>笔触、填充</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。</p><p>笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。</p><h2 id="3-绘制路径"><a href="#3-绘制路径" class="headerlink" title="3. 绘制路径"></a>3. 绘制路径</h2><p>使用 <code>beginPath()</code> 代表开始绘制；<code>moveTo(x, y)</code> 代表将笔触移动到某一坐标；<code>lineTo(x, y)</code> 代表直线绘制到某一点；使用 <code>stroke()</code> 能将绘制的图像显示出来。</p><p>如下可以绘制出一条折线：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">beginPath</span>();<br>ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>);<br>ctx.<span class="hljs-title function_">stroke</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lpbjrdg2j20es086q2s.jpg"></p><p>使用 <code>closePath()</code> 可以将最后一个绘制点【该绘制点是被用<code>moveTo(x, y)</code>打断绘制前的那个点】与第一个绘制点连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  ctx.<span class="hljs-title function_">beginPath</span>();<br>  ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>  ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>  ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>);<br>+ ctx.<span class="hljs-title function_">closePath</span>();<br>  ctx.<span class="hljs-title function_">stroke</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lpe43stnj20eq07jjr9.jpg"></p><p>连续使用 <code>moveTo()</code> 可以让开始新的绘制点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">beginPath</span>();<br>ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>);<br><br>ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">700</span>, <span class="hljs-number">400</span>);<br>ctx.<span class="hljs-title function_">stroke</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lpg9p7m3j20h009dwed.jpg"></p><h2 id="4-绘制样式"><a href="#4-绘制样式" class="headerlink" title="4. 绘制样式"></a>4. 绘制样式</h2><p>在绘制前可以对绘制的线段进行样式设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-property">lineWidth</span> = <span class="hljs-string">&quot;10&quot;</span>;<br>ctx.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;red&quot;</span>;<br>... ...<br>ctx.<span class="hljs-title function_">stock</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lpw1q9aqj20hk0a9a9y.jpg"></p><p>在绘制之后，使用 <code>fill()</code> 可以填充封闭图像（如果没有封闭也会自动封闭）的颜色，设置 <code>fillStyle</code> 属性可以来设置填充颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">... ...<br>ctx.<span class="hljs-title function_">stock</span>();<br>ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;skyblue&quot;</span><br>ctx.<span class="hljs-title function_">fill</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lq0n8juzj20hh09wmx4.jpg"></p><p>使用了 <code>fill()</code> 之后，Canvas会自动认为之前的绘制操已经绘制了一个独立的图形。</p><h2 id="6-快速绘制"><a href="#6-快速绘制" class="headerlink" title="6. 快速绘制"></a>6. 快速绘制</h2><p><code>strokeReact(x, y, w, h)</code>快速绘制一个矩形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;lightseagreen&quot;</span><br>ctx.<span class="hljs-title function_">strokeReact</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lqaiu2eoj20b706xt8j.jpg"></p><p>filRecto是一个快捷方法，让你省略了beginPath、move To、lineTo。所以fillRect（100，100，300，200）等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">move</span>(<span class="hljs-number">100</span>，<span class="hljs-number">100</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">400</span>，<span class="hljs-number">100</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">400</span>，<span class="hljs-number">300</span>);<br>ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">100</span>，<span class="hljs-number">300</span>);<br>ctx.<span class="hljs-property">closePath</span>（);<br>ctx.<span class="hljs-title function_">fill</span>();<br></code></pre></td></tr></table></figure><h2 id="6-绘制复杂图像"><a href="#6-绘制复杂图像" class="headerlink" title="6. 绘制复杂图像"></a>6. 绘制复杂图像</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">500</span>; i += <span class="hljs-number">10</span>) &#123;<br>  ctx.<span class="hljs-title function_">beginPath</span>();<br>  ctx.<span class="hljs-title function_">moveTo</span>(i, i);<br>  ctx.<span class="hljs-title function_">lineTo</span>(i + <span class="hljs-number">200</span>, i);<br>  ctx.<span class="hljs-title function_">lineTo</span>(i, i + <span class="hljs-number">300</span>);<br>  ctx.<span class="hljs-title function_">closePath</span>();<br>  ctx.<span class="hljs-title function_">stroke</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lqfwcsqoj20js0edmxi.jpg"></p><h2 id="7-API"><a href="#7-API" class="headerlink" title="7. API"></a>7. API</h2><p>方法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">beginPath</span><span class="hljs-params">()</span></span> 代表开始绘制<br><br><span class="hljs-function"><span class="hljs-title">moveTo</span><span class="hljs-params">(x, y)</span></span> 代表将笔触移动到某一坐标<br><br><span class="hljs-function"><span class="hljs-title">lineTo</span><span class="hljs-params">(x, y)</span></span> 代表直线绘制到某一点<br><br><span class="hljs-function"><span class="hljs-title">stroke</span><span class="hljs-params">()</span></span> 能将绘制的图像显示出来<br><br><span class="hljs-function"><span class="hljs-title">fill</span><span class="hljs-params">()</span></span> 可以填充封闭图像<br></code></pre></td></tr></table></figure><p>属性：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">lineWidth</span> 设置绘制线的宽度<br><br>strokeStyle 设置绘制线的颜色样式<br><br>fillStyle 设置填充色的样式<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lpnbvtz1j20ny0budhr.jpg"></p><h1 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h1><h2 id="1-绘制弧线"><a href="#1-绘制弧线" class="headerlink" title="1. 绘制弧线"></a>1. 绘制弧线</h2><p>使用 <code>arc(x, y, r, startRad, endRad, bollen)</code> 绘制弧线，arc属于笔触，需要使用<code>beginPath()</code>和<code>stroke()</code>来设置开始与绘制动作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">beginPath</span>();<br>ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>ctx.<span class="hljs-title function_">stroke</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2ly5tu2fnj20bj08jjrg.jpg"></p><p>整圆就是 <code>ctx.arc(200, 200, 100, 0, Math.PI*2, true);</code></p><p>绘制笑脸的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span>&gt;</span>对不起您的浏览器不支持画布！<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 得到画布</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> myCanvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#myCanvas&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-comment">// 上下文，就相当于打开ps之后让你新建画布</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> ctx = myCanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-comment">// 开始绘制路径</span></span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">90</span>, <span class="hljs-number">140</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">300</span>, <span class="hljs-number">140</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">beginPath</span>();</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">2.5</span>, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript">  ctx.<span class="hljs-title function_">stroke</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lyb1ahmfj20bc0bt0sz.jpg"></p><h2 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h2><p>方法：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">arc(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> r<span class="hljs-punctuation">,</span> startRad<span class="hljs-punctuation">,</span> endRad<span class="hljs-punctuation">,</span> bollen) <br>绘制弧度，xy为圆心坐标，r为绘制半径，startRad为初始角度，endRad为最终角度，bollen设置为<span class="hljs-keyword">true</span>为逆时针绘制<span class="hljs-keyword">false</span>为顺时针绘制<br></code></pre></td></tr></table></figure><h1 id="绘制渐变"><a href="#绘制渐变" class="headerlink" title="绘制渐变"></a>绘制渐变</h1><h2 id="1-创建渐变色"><a href="#1-创建渐变色" class="headerlink" title="1. 创建渐变色"></a>1. 创建渐变色</h2><p>使用 <code>createLinearrGradient(x1, y1, x2, y2)</code> 创建一个渐变对象，用 <code>addColorStop(rate, color)</code> 添加渐变颜色，将画布的 <code>fillStyle</code> 属性设置为这个渐变对象，即可以填充渐变颜色。</p><p>如绘制一个矩形，矩形内的填充色为从<code>blue</code>渐变到<code>red</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lingrad = ctx.<span class="hljs-title function_">createLinearGradient</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>lingrad.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;red&#x27;</span>);<br>lingrad.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;blue&#x27;</span>);<br><br>ctx.<span class="hljs-property">fillStyle</span> = lingrad;<br>ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2lzazsgdcj20es0erglz.jpg"></p><h2 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2. API"></a>2. API</h2><p>方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create<span class="hljs-constructor">LinearrGradient(<span class="hljs-params">x1</span>, <span class="hljs-params">y1</span>, <span class="hljs-params">x2</span>, <span class="hljs-params">y2</span>)</span> <br>创建一个渐变对象，(x1, y1)是渐变的起始坐标，(x2, y2)是渐变的结束坐标<br><br>add<span class="hljs-constructor">ColorStop(<span class="hljs-params">rate</span>, <span class="hljs-params">color</span>)</span><br>添加渐变颜色，rate为一个<span class="hljs-built_in">int</span>值，初始值为<span class="hljs-number">0</span>，colr为一个颜色<br></code></pre></td></tr></table></figure><h1 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h1><h2 id="1-添加文字"><a href="#1-添加文字" class="headerlink" title="1. 添加文字"></a>1. 添加文字</h2><p>使用 <code>fillText(content, x, y)</code> 来设置文字，注意(x, y)为文字基线的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">fillText</span>(<span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h2 id="2-调整样式"><a href="#2-调整样式" class="headerlink" title="2. 调整样式"></a>2. 调整样式</h2><p>通过 <code>font</code> 属性来设置字体、字号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;宋体&quot;</span><br></code></pre></td></tr></table></figure><p><code>font</code> 的级联样式 <code>ctx.font = &quot;font-size font-family&quot;</code></p><h1 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h1><h2 id="1-添加图片"><a href="#1-添加图片" class="headerlink" title="1. 添加图片"></a>1. 添加图片</h2><p>添加一个图片首先要创建一个<code>img</code>的实例，设置实例的<code>src</code>，监听这个实例的load事件，当图片加载完成后，利用 <code>drawImage(img, x, y)</code> 绘制出图片，如下实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;images/0.jpg&quot;</span>;<br>img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2. API"></a>2. API</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">draw<span class="hljs-constructor">Image(<span class="hljs-params">img</span>, <span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">w</span>, <span class="hljs-params">h</span>)</span> <br>img为一个图片示例，xy为图片左上角坐标，w为图片宽度，h为图片高度<br><br>draw<span class="hljs-constructor">Image(<span class="hljs-params">img</span>, X, Y, W, H, <span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">w</span>, <span class="hljs-params">h</span>)</span> <br>img为一个图片示例，XYWH可以设置图片的切片位置<br></code></pre></td></tr></table></figure><h1 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><p>canvas中元素不能运动，因为上屏幕之后就再也得不到它了，没有任何变量可以持有。</p><p>所以必须通过重绘一个新的矩形，利用视觉暂留，形成运动。</p><p>清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → …</p><p>清屏：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>)<br></code></pre></td></tr></table></figure><h2 id="2-面向对象制变成作运动函数"><a href="#2-面向对象制变成作运动函数" class="headerlink" title="2. 面向对象制变成作运动函数"></a>2. 面向对象制变成作运动函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Circle</span>(<span class="hljs-params">x, y, r, color</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><span class="hljs-title class_">Circle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  ctx.<span class="hljs-title function_">beginPath</span>();<br>  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>;<br>  ctx.<span class="hljs-title function_">fill</span>();<br>&#125;<br><span class="hljs-title class_">Circle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> += <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> yuan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&quot;blue&quot;</span>);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>)<br>  yuan.<span class="hljs-title function_">update</span>();<br>  yuan.<span class="hljs-title function_">render</span>();<br>&#125;, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/a71efaafly1g2m0noi2byg20jo0czwf3.gif"></p><h2 id="3-使用ES6来详细来面向对象编程编写动画函数"><a href="#3-使用ES6来详细来面向对象编程编写动画函数" class="headerlink" title="3. 使用ES6来详细来面向对象编程编写动画函数"></a>3. 使用ES6来详细来面向对象编程编写动画函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    actorsArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;所有演员必须重写render函数&quot;</span>)<br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 留空为非必须定义项</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 圆类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Actor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r, color</span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    ctx.<span class="hljs-title function_">beginPath</span>();<br>    ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>    ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>;<br>    ctx.<span class="hljs-title function_">fill</span>();<br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>++;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 所有演员的数组</span><br><span class="hljs-keyword">var</span> actorsArr = []<br><br><span class="hljs-keyword">var</span> yuan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&quot;red&quot;</span>);<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; actorsArr.<span class="hljs-property">length</span>; i++) &#123;<br>    actorsArr[i].<span class="hljs-title function_">update</span>();<br>    actorsArr[i].<span class="hljs-title function_">render</span>();<br>  &#125;<br>&#125;, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速使用</tag>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript中的函数节流与函数防抖</title>
    <link href="/2022/04/dcb640d619bb.html"/>
    <url>/2022/04/dcb640d619bb.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>函数节流和函数防抖都是用来优化性能，以及避免短时间内连续调用某个函数的方案。我们通过以下两个例子，来理解两种方案，以及它们的应用场景。</p></blockquote><h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>函数节流即为，一个函数执行一次后，只有大于设定的执行周期后，才会执行第二次。</p><p>这里我们可以理解为当一个函数立即执行后，它需要一个冷却时间才能被执行第二次，也就是我们需要去节制函数的调用次数，即为节流。</p><p>我们可以通过检测两次函数调用的时间差，如果在设定的函数冷却时间之内，则不能执行，如果在冷却时间之外则可以执行。通过函数节流可以优化Javascript的性能，防止一个函数被无差别的多次反复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JS核心/01.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数节流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn 要被节流的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delay 规定的时间（函数执行的冷却时间）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 需要通过闭包来保存lastTime的状态，否则每次调用lastTime都会被初始化为0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (nowTime - lastTime &gt; delay) &#123;<br>      fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 解决fn函数内this指向问题，如果不绑定this，函数的调用者为window（因为在这里执行函数函数前没有执行者），如果绑定了this，函数的this就指向了调用者本身</span><br>      lastTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> fun = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;触发了！&quot;</span>);<br>&#125;, <span class="hljs-number">500</span>);<br><br><span class="hljs-title function_">fun</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>();<br>&#125;, <span class="hljs-number">400</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>();<br>&#125;, <span class="hljs-number">600</span>)<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">触发了！<br>触发了！<br></code></pre></td></tr></table></figure><h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p>函数防抖即为，一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。</p><p>也就是说说一个方法将执行时，它会在一段时间内等待有没有事件第二次触发这个方法，如果有它就不执行了，如果没有才执行。</p><p>我们可以通过定时器，在方法第一次调用时，设置一个定时器，然后触发方法，假如在方法被触发前，该方法又被调用了，那在第二次调用前，会清除第一次调用方法而生成的定时器，重新再生成一个定时器去执行方法。</p><p>当我们页面上有一个按钮，希望用户在多次快速点击按钮时，仅触发一次按钮效果，我们就可以使用函数防抖机制，来避免用户在快速点击按钮时，连续触发多次方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数防抖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn 添加防抖的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delay 防抖间隔时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-comment">// 记录上一次的延时器</span><br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 清除上一次的延时器</span><br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <span class="hljs-comment">// 获取传入方法内部的参数</span><br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-comment">// 重新设定新的延时器</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> fun = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了！&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>()<br>&#125;, <span class="hljs-number">200</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>()<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>()<br>&#125;, <span class="hljs-number">400</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fun</span>(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>)<br>&#125;, <span class="hljs-number">1402</span>)<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span><br><span class="hljs-literal">undefined</span><br>触发了！<br><span class="hljs-number">111</span><br><span class="hljs-number">222</span><br>触发了！<br></code></pre></td></tr></table></figure><h1 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h1><p>函数节流是给函数执行设定一个冷却时间，函数被触发后在某固定一时间段内无法被触发第二次，它响应第一个触发者而忽略后面的触发者。</p><p>函数防抖是推迟了函数的执行，只响应后面的触发者，而抛弃前面的触发者，它的执行时间可以被无限推迟。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 如何卸载 deb 安装的第三方应用</title>
    <link href="/2022/04/723cf9bbb17e.html"/>
    <url>/2022/04/723cf9bbb17e.html</url>
    
    <content type="html"><![CDATA[<p>如果你是在 Ubuntu 应用商店中安装的应用，可以通过查看『已安装』面板进行卸载，但是假如你使用 <code>.deb</code> 文件安装了第三方应用，是无法通过应用商店进行写在的，这时就需要通过指令卸载。</p><p>首先通过 <code>dpkg</code> 命令列出你已经安装的应用，可以使用 <code>grep</code> 指令进行过滤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg --list | grep app_name<br></code></pre></td></tr></table></figure><p>之后可以在终端中使用 <code>dpkg -r</code> 来卸载该应用程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg -r app_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS爬虫基础原理及实战</title>
    <link href="/2022/02/f308d3924314.html"/>
    <url>/2022/02/f308d3924314.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-原始数据的获取"><a href="#1-原始数据的获取" class="headerlink" title="1. 原始数据的获取"></a>1. 原始数据的获取</h1><h2 id="1-1-原生-http-模块获取数据"><a href="#1-1-原生-http-模块获取数据" class="headerlink" title="1.1 原生 http 模块获取数据"></a>1.1 原生 http 模块获取数据</h2><p>http 是 node 内置的一个模块，可以使用该模块来发送一个简单的 http 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><br>http.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>, <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&quot;utf8&quot;</span>);<br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-2-使用-request-模块获取数据"><a href="#1-2-使用-request-模块获取数据" class="headerlink" title="1.2 使用 request 模块获取数据"></a>1.2 使用 request 模块获取数据</h2><p>request 是一个第三方模块，可以更好的封装请求服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-title function_">request</span>(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>, <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error: &quot;</span>, error);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res: &quot;</span>, res);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;body: &quot;</span>, body);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-3-使用-iconv-lite-解决编码问题"><a href="#1-3-使用-iconv-lite-解决编码问题" class="headerlink" title="1.3 使用 iconv-lite 解决编码问题"></a>1.3 使用 iconv-lite 解决编码问题</h2><p>我们使用 <a href="https://www.ygdy8.net/index.html">阳光电影网</a> 作为原始数据的抓取网站对象，但是由于该网站过于老旧，网站的编码格式为 <code>gb2312</code>，而原生 node 中支持的编码格式为：</p><ul><li>ascii</li><li>base64</li><li>binary</li><li>hex</li><li>ucs2&#x2F;ucs-2&#x2F;utf16le&#x2F;utf-16le</li><li>utf8&#x2F;utf-8</li><li>latin1 (ISO8859-1, only in node 6.4.0+)</li></ul><p>并不支持 <code>gb2312</code>，且默认回按照 <code>utf8</code> 的编码格式去解析文本，因此直接抓取网页数据会返回乱码结果，使用 <code>iconv-lite</code> 模块可以解决这一问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-keyword">const</span> iconv = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;iconv-lite&quot;</span>);<br><br><span class="hljs-title function_">request</span>(<br>  <span class="hljs-string">&quot;https://www.ygdy8.net/html/gndy/oumei/list_7_2.html&quot;</span>,<br>  &#123; <span class="hljs-attr">encoding</span>: <span class="hljs-literal">null</span> &#125;, <span class="hljs-comment">// 默认为 utf8 错误编码</span><br>  <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> bufs = iconv.<span class="hljs-title function_">decode</span>(body, <span class="hljs-string">&quot;gb2312&quot;</span>);<br>    <span class="hljs-keyword">const</span> html = bufs.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;utf8&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h1 id="2-数据的处理"><a href="#2-数据的处理" class="headerlink" title="2. 数据的处理"></a>2. 数据的处理</h1><h2 id="2-1-cheerio"><a href="#2-1-cheerio" class="headerlink" title="2.1 cheerio"></a>2.1 cheerio</h2><p><code>cheerio</code> 是一个模拟 jQuery 的运行再 node 环境下的 HTML 解析器，可以将 HTML 字符串按照 jQuery 的方式进行快捷处理：</p><p>Demo:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br><span class="hljs-keyword">const</span> $ = cheerio.<span class="hljs-title function_">load</span>(<span class="hljs-string">`&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;/h2&gt;`</span>);<br><br>$(<span class="hljs-string">&quot;h2.title&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;Hello there!&quot;</span>);<br>$(<span class="hljs-string">&quot;h2&quot;</span>).<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&quot;welcome&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($.<span class="hljs-title function_">html</span>());<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title welcome&quot;</span>&gt;</span>Hello there!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-并发抓取与处理数据"><a href="#2-2-并发抓取与处理数据" class="headerlink" title="2.2 并发抓取与处理数据"></a>2.2 并发抓取与处理数据</h2><p>我们仍以 <a href="https://www.ygdy8.net/index.html">阳光电影网</a> 作为数据的抓取对象，在其 <a href="https://www.ygdy8.net/html/gndy/oumei/list_7_1.html">欧美专区</a> 中可以获取到电影的列表，利用 Chrome 的开发者工具可以获取到每个电影详情页面的链接，并获取其节点的选择器。</p><p>通过 <code>cheerio</code> 我们可以选择到该节点并获取其链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对 request 模块进行封装</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">requestPromise</span> = url =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">request</span>(<br>      url,<br>      &#123; <span class="hljs-attr">encoding</span>: <span class="hljs-literal">null</span> &#125;, <span class="hljs-comment">// 默认为 utf8 错误编码</span><br>      <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) &#123;<br>          <span class="hljs-keyword">const</span> bufs = iconv.<span class="hljs-title function_">decode</span>(body, <span class="hljs-string">&quot;gb2312&quot;</span>);<br>          <span class="hljs-keyword">const</span> html = bufs.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;utf8&quot;</span>);<br>          <span class="hljs-title function_">resolve</span>(html);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;<br>    );<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> host = <span class="hljs-string">&quot;https://www.ygdy8.net&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = <span class="hljs-keyword">async</span> url =&gt; &#123;<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestPromise</span>(url);<br>  <span class="hljs-keyword">const</span> $ = cheerio.<span class="hljs-title function_">load</span>(html);<br>  $(<br>    <span class="hljs-string">&quot;.co_content8 ul table tbody tr:nth-child(2) td:nth-child(2) b a:nth-child(2)&quot;</span><br>  ).<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">i, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> href = $(item).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;href&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(href);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-title function_">getList</span>(<span class="hljs-string">&quot;https://www.ygdy8.net/html/gndy/oumei/list_7_1.html&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200127</span>/<span class="hljs-number">59623</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200127</span>/<span class="hljs-number">59620</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200127</span>/<span class="hljs-number">59619</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200125</span>/<span class="hljs-number">59616</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200123</span>/<span class="hljs-number">59611</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200123</span>/<span class="hljs-number">59610</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200121</span>/<span class="hljs-number">59608</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200121</span>/<span class="hljs-number">59607</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200120</span>/<span class="hljs-number">59605</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200119</span>/<span class="hljs-number">59600</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200119</span>/<span class="hljs-number">59598</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200117</span>/<span class="hljs-number">59597</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200117</span>/<span class="hljs-number">59596</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200116</span>/<span class="hljs-number">59592</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200116</span>/<span class="hljs-number">59591</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200116</span>/<span class="hljs-number">59590</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200115</span>/<span class="hljs-number">59589</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200115</span>/<span class="hljs-number">59588</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200115</span>/<span class="hljs-number">59587</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200114</span>/<span class="hljs-number">59583</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200114</span>/<span class="hljs-number">59582</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200114</span>/<span class="hljs-number">59581</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200113</span>/<span class="hljs-number">59577</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/dyzz/</span><span class="hljs-number">20200113</span>/<span class="hljs-number">59576</span>.html<br><span class="hljs-regexp">/html/g</span>ndy<span class="hljs-regexp">/jddy/</span><span class="hljs-number">20200113</span>/<span class="hljs-number">59575</span>.html<br></code></pre></td></tr></table></figure><p>当我们获取到一个电影的详情页面 url 后，就可以单独打开每个页面，然后利用 <code>cheerio</code> 去抓取数据详情。</p><p>我们通过分析电影详情页面，先输出单个电影的详情页：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMovieDetail</span> = <span class="hljs-keyword">async</span> url =&gt; &#123;<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestPromise</span>(url);<br>  <span class="hljs-keyword">const</span> $ = cheerio.<span class="hljs-title function_">load</span>(html);<br>  <span class="hljs-keyword">const</span> movie = &#123;<br>    <span class="hljs-attr">name</span>: $(<span class="hljs-string">&quot;.bd3l &gt; div.co_area2 &gt; div.title_all h1 font&quot;</span>).<span class="hljs-title function_">text</span>(),<br>    <span class="hljs-comment">// desc 过长文章中省略输出</span><br>    <span class="hljs-comment">// desc: $(&quot;#Zoom &gt; span &gt; p:nth-child(1)&quot;).text(), </span><br>    <span class="hljs-attr">picture</span>: $(<span class="hljs-string">&quot;#Zoom &gt; span &gt; p:nth-child(1) &gt; img:nth-child(1)&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;src&quot;</span>)<br>  &#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movie);<br>&#125;;<br><br><span class="hljs-title function_">getMovieDetail</span>(<span class="hljs-string">`https://www.ygdy8.net/html/gndy/dyzz/20200127/59623.html`</span>);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123; <br>  name: &#x27;<span class="hljs-number">2019</span>年剧情《谎言大师》BD中英双字幕&#x27;,<br>  picture: &#x27;https://lookimg.com/images/<span class="hljs-number">2020/01/26</span>/JMBaW.jpg&#x27; <br>&#125;<br></code></pre></td></tr></table></figure><p>结合了上面的抓取方法之后，我们可以采用并发的方式，去抓取欧美电影第一页的所有电影的详情信息，完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-comment">// 使用 iconv-lite 对老旧网站进行编码转换</span><br><span class="hljs-keyword">const</span> iconv = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;iconv-lite&quot;</span>);<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">requestPromise</span> = url =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">request</span>(<br>      url,<br>      &#123; <span class="hljs-attr">encoding</span>: <span class="hljs-literal">null</span> &#125;, <span class="hljs-comment">// 默认为 utf8 错误编码</span><br>      <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) &#123;<br>          <span class="hljs-keyword">const</span> bufs = iconv.<span class="hljs-title function_">decode</span>(body, <span class="hljs-string">&quot;gb2312&quot;</span>);<br>          <span class="hljs-keyword">const</span> html = bufs.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;utf8&quot;</span>);<br>          <span class="hljs-title function_">resolve</span>(html);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;<br>    );<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> host = <span class="hljs-string">&quot;https://www.ygdy8.net&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMovieDetail</span> = <span class="hljs-keyword">async</span> url =&gt; &#123;<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestPromise</span>(url);<br>  <span class="hljs-keyword">const</span> $ = cheerio.<span class="hljs-title function_">load</span>(html);<br>  <span class="hljs-keyword">const</span> movie = &#123;<br>    <span class="hljs-attr">name</span>: $(<span class="hljs-string">&quot;.bd3l &gt; div.co_area2 &gt; div.title_all h1 font&quot;</span>).<span class="hljs-title function_">text</span>(),<br>    <span class="hljs-comment">// desc: $(&quot;#Zoom &gt; span &gt; p:nth-child(1)&quot;).text(),</span><br>    <span class="hljs-attr">picture</span>: $(<span class="hljs-string">&quot;#Zoom &gt; span &gt; p:nth-child(1) &gt; img:nth-child(1)&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;src&quot;</span>)<br>  &#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movie);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = <span class="hljs-keyword">async</span> url =&gt; &#123;<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestPromise</span>(url);<br>  <span class="hljs-keyword">const</span> $ = cheerio.<span class="hljs-title function_">load</span>(html);<br>  $(<br>    <span class="hljs-string">&quot;.co_content8 ul table tbody tr:nth-child(2) td:nth-child(2) b a:nth-child(2)&quot;</span><br>  ).<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">i, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> href = $(item).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;href&quot;</span>);<br>    <span class="hljs-title function_">getMovieDetail</span>(host + href);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-title function_">getList</span>(<span class="hljs-string">&quot;https://www.ygdy8.net/html/gndy/oumei/list_7_1.html&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123; name: &#x27;<span class="hljs-number">2018</span>年高分获奖《他们已不再变老》BD英语中字&#x27;, picture: undefined &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年高分获奖剧情《痛苦与荣耀》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/14</span>/9d77f7ad<span class="hljs-number">1383</span>c<span class="hljs-number">453106</span>e321ea<span class="hljs-number">661160</span>6.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年惊悚剧情《劫匪/公路响马》BD中英双字幕&#x27;,<br>  picture: &#x27;https://lookimg.com/images/<span class="hljs-number">2020/01/21</span>/JO1zh.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年奇幻冒险《沉睡魔咒2》BD国英双语双字&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/01</span>/3ed5aaa5a2bff645bc<span class="hljs-number">258519</span>b<span class="hljs-number">6338</span>ba2.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年喜剧《白烂贱客2》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/13/75</span>3d9ea<span class="hljs-number">7958</span>f<span class="hljs-number">8898</span>fee58bca<span class="hljs-number">7418</span>c815.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年科幻动作《终结者：黑暗命运》BD中英双字幕&#x27;, picture: undefined &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年科幻喜剧《杰克茜/神机有毛病》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/15/20</span>bd24aca384f8b65c2d9ffc6fd<span class="hljs-number">4878</span>7.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年惊悚恐怖《落头氏之吻》BD泰语中字&#x27;, picture: undefined &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年获奖剧情《哈丽特/自由之火》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/18</span>/5d5b14f0d<span class="hljs-number">5335</span>3a5caaebac0bca7eca9.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2015</span>年高分悬疑剧情《误杀瞒天记》BD中字&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/16/10</span>9cb7e<span class="hljs-number">667131</span>a9abec<span class="hljs-number">842384</span>d109d5f.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动作《敢死七镖客》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/25</span>/8b4a82e<span class="hljs-number">4781</span>6c3e3bd4c2e56e5d222ef.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年剧情《谎言大师》BD中英双字幕&#x27;,<br>  picture: &#x27;https://lookimg.com/images/<span class="hljs-number">2020/01/26</span>/JMBaW.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年悬疑惊悚《布鲁克林秘案》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/14</span>/0b32b640a9f<span class="hljs-number">84260655004012</span>fe<span class="hljs-number">2502</span>f.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2014</span>年奇幻冒险《沉睡魔咒》BD国英双语双字&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/17</span>/6d181b<span class="hljs-number">7104</span>d0f8b7a<span class="hljs-number">0929</span>c<span class="hljs-number">3138</span>efe494.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年惊悚动作《快递员》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/14/35</span>ded36c5d4f<span class="hljs-number">54887244</span>f<span class="hljs-number">88539722</span>b8a.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动画喜剧《动物特工局》HD国语中字&#x27;,<br>  picture:<br>   &#x27;https://www.z4a.net/images/<span class="hljs-number">2020/01/26</span>/5f<span class="hljs-number">6998</span>b3eaa19ba6f.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年惊悚恐怖奇幻《睡梦医生加长版》BD中英双字幕&#x27;,<br>  picture: &#x27;https://lookimg.com/images/<span class="hljs-number">2020/01/24</span>/JdkMq.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年喜剧《交友网战/爱程攻防战》BD泰语中字&#x27;, picture: undefined &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年奇幻动作《阿比盖尔/魔法禁界》BD英语中字&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/08/92</span>aca31fe6be93f<span class="hljs-number">2896</span>d130be25a420b.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动画喜剧《雪人奇缘》BD英国粤三语双字&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2019/12/01/8275</span>cc39f94fa9eefb8d1bd<span class="hljs-number">451567</span>f67.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年惊悚恐怖《倒忌时/索命倒数》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/12</span>/3d1c934d4ab10c65a3ceed<span class="hljs-number">81635170</span>c6.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2017</span>年惊悚动作《全面营救》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/12/507227</span>70f<span class="hljs-number">1363</span>8a0e6ac<span class="hljs-number">21379912</span>fe6f.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动作《疾速杀机》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/13</span>/4fb382ac<span class="hljs-number">730377</span>ed36acf<span class="hljs-number">3306</span>ca<span class="hljs-number">9027</span>3.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动作《洛城夜巡》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/13</span>/bdc7f21d<span class="hljs-number">2140</span>9f6d9aa44d7d9fb5de10.jpg&#x27; &#125;<br>&#123; name: &#x27;<span class="hljs-number">2019</span>年动画喜剧《亚当斯一家》BD中英双字幕&#x27;,<br>  picture:<br>   &#x27;https://extraimage.net/images/<span class="hljs-number">2020/01/12</span>/c78cf2a<span class="hljs-number">4589</span>8a8f2f19b5a8bda1d<span class="hljs-number">3726</span>.jpg&#x27; &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-大量数据抓取的优化"><a href="#2-3-大量数据抓取的优化" class="headerlink" title="2.3 大量数据抓取的优化"></a>2.3 大量数据抓取的优化</h2><p>如果我们想要抓取整个欧美专区的所有电影信息，就需要获取每个页面的 url，我们先对其进行收集，这里以抓取200页数据为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> urlArr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>  urlArr.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/html/gndy/oumei/list_7_<span class="hljs-subst">$&#123;i&#125;</span>.html`</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(urlArr);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ <br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_0.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_1.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_2.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_3.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_4.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_5.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_6.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_7.html</span>&#x27;,<br>  <span class="hljs-symbol">&#x27;https://www.ygdy8.net/html/gndy/oumei/list_7_8.html</span>&#x27;,<br>  ... ...<br>]<br></code></pre></td></tr></table></figure><p>如果我们再 for 循环中直接去执行文章 2.2 步骤中的 <code>getList()</code> 方法，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>  <span class="hljs-title function_">getList</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/html/gndy/oumei/list_7_<span class="hljs-subst">$&#123;i&#125;</span>.html`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这就相当于同时异步访问 200*25 个 url，这对于资源有限的服务器来说压力是巨大的，因此我们要对其进行优化。</p><p>我们已知 <code>getList()</code> 方法会抓取电影列表的数据，然后再开启并发任务去抓取每个电影的详情，因此我们只要控制住 <code>getList()</code> 方法，不让其并发执行即可，因此我们会想到使用 <code>await</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">getList</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/html/gndy/oumei/list_7_<span class="hljs-subst">$&#123;i&#125;</span>.html`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是再同步方法中是无法使用 <code>await</code> 的，那么有什么方法可以使用呢？如果创建一个异步方法，将 <code>for</code> 循环写入该异步方法中，然后再调用创建的异步方法可以解决，但是这样写并不优雅。我们采用另一种思路，使用 <code>Array.reduce()</code> 来创建异步方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> urlArr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>  urlArr.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/html/gndy/oumei/list_7_<span class="hljs-subst">$&#123;i&#125;</span>.html`</span>);<br>&#125;<br><br>urlArr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">rs, url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> rs.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">async</span> resolve =&gt; &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">getList</span>(url);<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;);<br>  &#125;);<br>&#125;, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>());<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> urlArr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>  urlArr.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/html/gndy/oumei/list_7_<span class="hljs-subst">$&#123;i&#125;</span>.html`</span>);<br>&#125;<br><br>urlArr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">rs, url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> rs.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">getList</span>(url);<br>  &#125;);<br>&#125;, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>());<br></code></pre></td></tr></table></figure><p>其原理实际上都是利用 <code>reduce()</code> 方法创建了多个异步方法，并且使用 <code>await</code> 去等待异步方法的执行，这样我们就可以更好的限制同时发出的并发请求数量。</p><p><code>Array.reduce(callback, initialValue)</code> 的参数详情如下：</p><p><code>callback</code></p><p>执行数组中每个值 (如果没有提供 <code>initialValue则第一个值除外</code>)的函数，包含四个参数：</p><ul><li><p><strong><code>accumulator</code></strong></p><p>累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或<code>initialValue</code>（见于下方）。</p></li><li><p><code>currentValue</code></p><p>数组中正在处理的元素。</p></li><li><p><code>index</code> 可选</p><p>数组中正在处理的当前元素的索引。 如果提供了<code>initialValue</code>，则起始索引号为0，否则从索引1起始。</p></li><li><p><code>array</code>可选</p><p>调用<code>reduce()</code>的数组</p></li></ul><p><code>initialValue</code>可选</p><p>作为第一次调用 <code>callback</code>函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript设计模式——观察者模式与发布订阅模式的对比</title>
    <link href="/2022/01/063597e66729.html"/>
    <url>/2022/01/063597e66729.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-实现场景"><a href="#1-实现场景" class="headerlink" title="1. 实现场景"></a>1. 实现场景</h1><blockquote><p>分析的例子来源于：<a href="https://www.zhihu.com/question/23486749">https://www.zhihu.com/question/23486749</a> 作者：无邪气</p></blockquote><p>存在有这样一个场景：当在一个数据中心中，用户需要从数据中心中取数据，等待数据中心将数据打包后，用户便可以获取数据。</p><h1 id="2-观察者模式的实现"><a href="#2-观察者模式的实现" class="headerlink" title="2. 观察者模式的实现"></a>2. 观察者模式的实现</h1><h2 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h2><p><img src="https://s2.loli.net/2023/04/22/UKEnGWFjJ8azfRc.png"></p><h2 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h2><p>在程序创建了一个任务中心后，再分别创建多个 DownloadTask 即创建多个下载任务，使用 <code>dataHub.addDownloadTask()</code> 来将下载任务添加到任务列表中，那么接下来当任务中心使用 <code>dataHub.notify()</code> 方法传入数据链接后，下载线程就会得到数据链接并实施具体的方法。</p><blockquote><p>客户端不会去主动调用下载线程（观察者）的 <code>finish()</code> 方法，而是交给数据中心（被观察对象）去调用。</p></blockquote><h3 id="2-2-1-创建-DownloadTask-类作为观察者"><a href="#2-2-1-创建-DownloadTask-类作为观察者" class="headerlink" title="2.2.1 创建 DownloadTask 类作为观察者"></a>2.2.1 创建 DownloadTask 类作为观察者</h3><p>DownloadTask类即为该系统中的观察者，观察者有 <code>id</code>、<code>loaded</code>、<code>url</code> 属性，在其上面挂载了一个 <code>finish()</code> 方法，当被观察对象发出指令操作时，这个方法就会被触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DownloadTask</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">false</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-title class_">DownloadTask</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finish</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> + <span class="hljs-string">&#x27; load data from &#x27;</span> + url);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-创建-DownloadTaskList-类作为管理器"><a href="#2-2-2-创建-DownloadTaskList-类作为管理器" class="headerlink" title="2.2.2 创建 DownloadTaskList 类作为管理器"></a>2.2.2 创建 DownloadTaskList 类作为管理器</h3><p>DownloadTaskList类主要负责提供一个任务队列和一些附加的管理方法，方便管理观察者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DownloadTaskList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span> = [];<br>&#125;<br><br><span class="hljs-title class_">DownloadTaskList</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getCount</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span>.<span class="hljs-property">length</span>;<br>&#125;;<br><br><span class="hljs-title class_">DownloadTaskList</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span>[index];<br>&#125;;<br><br><span class="hljs-title class_">DownloadTaskList</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span>.<span class="hljs-title function_">push</span>(obj);<br>&#125;;<br><br><span class="hljs-title class_">DownloadTaskList</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">remove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> downloadTaskCount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span>.<span class="hljs-title function_">getCount</span>();<br>  <span class="hljs-keyword">while</span> (i &lt; downloadTaskCount) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span>[i] === obj) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTaskList</span>.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    i++;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-创建-DataHub-类作为被观察对象"><a href="#2-2-3-创建-DataHub-类作为被观察对象" class="headerlink" title="2.2.3 创建 DataHub 类作为被观察对象"></a>2.2.3 创建 DataHub 类作为被观察对象</h3><p>DataHub类作为被观察对象，被观察对象通知观察者其实现原理就是在 <code>DataHub</code> 类的 <code>notify()</code> 方法中，去遍历数据中心中的下载队列（观察者队列）中的所有任务（观察者），在这些下载任务的实例（观察者）上调用其 <code>finish()</code> 方法，并传入参数 <code>url</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataHub</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTaskList</span>();<br>&#125;<br><br><span class="hljs-title class_">DataHub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addDownloadTask</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">downloadTask</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span>.<span class="hljs-title function_">add</span>(downloadTask);<br>&#125;;<br><br><span class="hljs-title class_">DataHub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">removeDownloadTask</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">downloadTask</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span>.<span class="hljs-title function_">remove</span>(downloadTask);<br>&#125;;<br><br><span class="hljs-title class_">DataHub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">notify</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> downloadTaskCount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span>.<span class="hljs-title function_">getCount</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; downloadTaskCount; i++) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadTasks</span>.<span class="hljs-title function_">get</span>(i).<span class="hljs-title function_">finish</span>(url);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-4-客户端"><a href="#2-2-4-客户端" class="headerlink" title="2.2.4 客户端"></a>2.2.4 客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个数据中心</span><br><span class="hljs-keyword">var</span> dataHub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataHub</span>();<br><br><span class="hljs-comment">// 现在用户来取数据了，创建两个任务</span><br><span class="hljs-keyword">var</span> downloadTask1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTask</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> downloadTask2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTask</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 将任务添加到观察者队列中</span><br>dataHub.<span class="hljs-title function_">addDownloadTask</span>(downloadTask1);<br>dataHub.<span class="hljs-title function_">addDownloadTask</span>(downloadTask2);<br><br><span class="hljs-comment">// 数据打包完成了</span><br>dataHub.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;http://somedomain.someaddress&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-2-5-结果"><a href="#3-2-5-结果" class="headerlink" title="3.2.5 结果"></a>3.2.5 结果</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> load data <span class="hljs-keyword">from</span> http:<span class="hljs-comment">//somedomain.someaddress</span><br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> load data <span class="hljs-keyword">from</span> http:<span class="hljs-comment">//somedomain.someaddress</span><br></code></pre></td></tr></table></figure><h1 id="3-发布订阅模式的实现"><a href="#3-发布订阅模式的实现" class="headerlink" title="3. 发布订阅模式的实现"></a>3. 发布订阅模式的实现</h1><h2 id="3-1-UML类图"><a href="#3-1-UML类图" class="headerlink" title="3.1 UML类图"></a>3.1 UML类图</h2><p><img src="https://s2.loli.net/2023/04/22/2NSnwFA4Vcx6UIh.png"></p><h2 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h2><h3 id="3-2-1-定义-DataHub-类作为发布者"><a href="#3-2-1-定义-DataHub-类作为发布者" class="headerlink" title="3.2.1 定义 DataHub 类作为发布者"></a>3.2.1 定义 DataHub 类作为发布者</h3><p>创建 DataHub 作为事件的发布者，当发布者调用 <code>notify()</code> 方法后，会触发一个回调函数，在这个回调函数中会去调用 DownloadManager 对象下的 <code>publish()</code> 方法，这样就相当于做了一个事件的发布。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataHub</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">DataHub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">notify</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-title function_">callback</span>(url);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-定义-DownloadManager-类作为事件通道"><a href="#3-2-2-定义-DownloadManager-类作为事件通道" class="headerlink" title="3.2.2 定义 DownloadManager 类作为事件通道"></a>3.2.2 定义 DownloadManager 类作为事件通道</h3><p>DownloadManager 对象是发布订阅模式中的数据处理中心，它负责了事件的订阅与发布，包括处理发布的消息数据。</p><p>DownloadManager 类中有两个属性，一个是 <code>events</code> 存放了订阅事件以及对应事件的订阅者，<code>uId</code> 作为计数器，记录订阅者的ID。</p><p>其中，<code>events</code> 的结构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <br>  <span class="hljs-string">&quot;订阅事件1&quot;</span>: [<br>    &#123;<span class="hljs-attr">taskId</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Function</span>&#125;, <span class="hljs-comment">// 订阅者1_1</span><br>    &#123;<span class="hljs-attr">taskId</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Function</span>&#125;, <span class="hljs-comment">// 订阅者1_2</span><br>  ], <br>  <span class="hljs-string">&quot;订阅事件2&quot;</span>: [<br>    &#123;<span class="hljs-attr">taskId</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Function</span>&#125;, <span class="hljs-comment">// 订阅者2_1</span><br>    &#123;<span class="hljs-attr">taskId</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Function</span>&#125;, <span class="hljs-comment">// 订阅者2_2</span><br>  ]&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DownloadManager</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">uId</span> = -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 DownloadManager 的追加一个 publish 方法函数，用来给发布者发布某一事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发布</span><br><span class="hljs-title class_">DownloadManager</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">publish</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, url</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventType]) &#123;<br>    <span class="hljs-comment">// 判断是否有订阅者订阅该事件,</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">var</span> subscribers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventType],<br>    count = subscribers ? subscribers.<span class="hljs-property">length</span> : <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 循环遍历订阅事件队列中的订阅者</span><br>  <span class="hljs-keyword">while</span> (count--) &#123;<br>    <span class="hljs-keyword">var</span> subscriber = subscribers[count];<br>    subscriber.<span class="hljs-title function_">handler</span>(eventType, subscriber.<span class="hljs-property">taskId</span>, url);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 DownloadManager 的追加一个 subscribe 方法函数，用来给订阅者订阅某一事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 订阅</span><br><span class="hljs-title class_">DownloadManager</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">subscribe</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, handler</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventType]) &#123;<br>    <span class="hljs-comment">// 如果订阅的事件不存在，就在 events 对象中创建一个，让其值为一个空数组，用来存放订阅该事件的订阅者</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventType] = [];<br>  &#125;<br>  <span class="hljs-keyword">var</span> taskId = (++<span class="hljs-variable language_">this</span>.<span class="hljs-property">uId</span>).<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-comment">// 将该订阅者放入对应的事件的订阅者队列中</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventType].<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">taskId</span>: taskId,<br>    <span class="hljs-attr">handler</span>: handler<br>  &#125;);<br>  <span class="hljs-keyword">return</span> taskId;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3-客户端函数"><a href="#3-2-3-客户端函数" class="headerlink" title="3.2.3 客户端函数"></a>3.2.3 客户端函数</h3><p>客户端一定要遵循先设置订阅，后设置发布的原则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个数据中心</span><br><span class="hljs-keyword">var</span> dataHub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataHub</span>();<br><br><span class="hljs-comment">// 创建一个下载事件管理器</span><br><span class="hljs-keyword">var</span> downloadManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadManager</span>();<br><br><span class="hljs-comment">// 创建一个下载器</span><br><span class="hljs-keyword">var</span> dataLoader = <span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, taskId, url</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task &#x27;</span> + taskId + <span class="hljs-string">&#x27; load data from &#x27;</span> + url);<br>&#125;<br><br><span class="hljs-comment">// 用户来请求数据了，从 downloadManager 订阅事件</span><br><span class="hljs-keyword">var</span> downloadTask1 = downloadManager.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;dataReady&#x27;</span>, dataLoader);<br><span class="hljs-keyword">var</span> downloadTask2 = downloadManager.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;dataReady2&#x27;</span>, dataLoader);<br><br><span class="hljs-comment">// 数据打包完成了</span><br>dataHub.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;http://somedomain.someaddress&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-comment">// 向 downloadManager 发布一个事件</span><br>  downloadManager.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;dataReady&#x27;</span>, url);<br>&#125;);<br><br>dataHub.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;http://somedomain2.someaddress&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-comment">// 向 downloadManager 发布一个事件</span><br>  downloadManager.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;dataReady2&#x27;</span>, url);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-2-4-结果"><a href="#3-2-4-结果" class="headerlink" title="3.2.4 结果"></a>3.2.4 结果</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Task</span> <span class="hljs-number">0</span> load data <span class="hljs-keyword">from</span> http:<span class="hljs-comment">//somedomain.someaddress</span><br><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> load data <span class="hljs-keyword">from</span> http:<span class="hljs-comment">//somedomain2.someaddress</span><br></code></pre></td></tr></table></figure><h1 id="4-区别"><a href="#4-区别" class="headerlink" title="4. 区别"></a>4. 区别</h1><p>观察者模式不需要中间件，被观察对象可以直接将事件通知给观察者。</p><p>然而发布订阅模式，则需要一个中间的发布订阅管理器，来进行发布事件与订阅事件的详细方法实现。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生AJAX的使用</title>
    <link href="/2021/12/da353d30788b.html"/>
    <url>/2021/12/da353d30788b.html</url>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1-XMLHttpRequest"><a href="#1-XMLHttpRequest" class="headerlink" title="1. XMLHttpRequest"></a>1. XMLHttpRequest</h2><h3 id="1-1-原生XMLHttpRequest的使用"><a href="#1-1-原生XMLHttpRequest的使用" class="headerlink" title="1.1 原生XMLHttpRequest的使用"></a>1.1 原生XMLHttpRequest的使用</h3><p><code>xhr.opne([Method], [url], [bollen])</code> 创建一个连接，第一个参数为请求的方法，如 GET、POST；第二个参数为请求的 url 地址；第三个参数为一个布尔值，代表是否以同步(Sync)方式加载，默认为false(异步Asyn方式加载)</p><p><code>xhr.onreadystatechange</code> xhr 对象状态改变后触发的函数事件</p><p><code>xhr.readyState</code> xhr 对象当前的状态</p><p><code>xhr.status</code> 获取发送数据返回的状态码</p><p><code>xhr.responseText</code> 返回的数据</p><p><code>xhr.send()</code> 发送的数据，如果仅仅发送一个请求而不传送数据则传入参数为 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/api&quot;</span>, <span class="hljs-literal">false</span>);<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>)&#123;<br>    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2-兼容性问题"><a href="#1-2-兼容性问题" class="headerlink" title="1.2 兼容性问题"></a>1.2 兼容性问题</h3><ul><li>IE低版本使用ActiveXObject，和W3C标准不一样</li><li>IE低版本使用量以非常少，很多网站都早已不支持</li><li>建议对E低版本的兼容性：了解即可，无需深究</li><li>如果遇到对I正低版本要求苛刻的面试，果断放弃</li></ul><h2 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2. 状态码"></a>2. 状态码</h2><h3 id="2-1-readyState的状态码"><a href="#2-1-readyState的状态码" class="headerlink" title="2.1 readyState的状态码"></a>2.1 readyState的状态码</h3><ul><li>0 -（未初始化）还没有调用send0方法</li><li>1 -（载入）已调用send）方法，正在发送请求</li><li>2 -（载入完成）send）方法执行完成，已经接收到全部响应内容</li><li>3 -（交互）正在解析响应内容</li><li>4 -（完成）响应内容解析完成，可以在客户端调用了【常用】</li></ul><h2 id="2-2-state网络状态码"><a href="#2-2-state网络状态码" class="headerlink" title="2.2 state网络状态码"></a>2.2 state网络状态码</h2><ul><li>2xx-表示成功处理请求。如200</li><li>3xx-需要重定向，浏览器直接跳转</li><li>4xx-客户端请求错误，如404</li><li>5xx-服务器端错误</li></ul><h2 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a>3. 跨域</h2><h3 id="3-1-什么是跨域"><a href="#3-1-什么是跨域" class="headerlink" title="3.1 什么是跨域"></a>3.1 什么是跨域</h3><p>浏览器有同源策略，不允许ajax访问其他域接口</p><p>跨域条件：协议、域名、端口（HTTP默认端口是80，HTTPS默认端口是443），有一个不同就算跨域</p><p>允许跨域的三个标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">xxx</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">xxxx</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">xxx</span>&gt;</span><br></code></pre></td></tr></table></figure><p>三个标签的应用场景：</p><ul><li><code>&lt;img&gt;</code> 用于打点统计，统计网站可能是其他域</li><li><code>&lt;link&gt;&lt;script&gt;</code> 可以使用CDN，CDN的也是其他域</li><li><code>&lt;script&gt;</code> 可以用于JSONP</li></ul><p>跨域注意事项：</p><ul><li>所有的跨域请求都必须经过信息提供方允许</li><li>如果未经允许即可获取，那是浏览器同源策略出现漏洞</li></ul><h3 id="3-2-JSONP"><a href="#3-2-JSONP" class="headerlink" title="3.2 JSONP"></a>3.2 JSONP</h3><p>原理：</p><p><code>&lt;script&gt;</code> 标签允许跨域。</p><p>步骤：</p><p>（1）在页面的主Javascript文件中去定义一个方法作为处理JSONP数据的函数，这个方法必须挂载在window上或者是在全局定义的，方法的某一参数为规定为<code>data</code>，用来接收以JSONP方法传入的数据，在方法内部设置与<code>data</code>相关的操作。</p><p>（2）从外部引入一个 <code>&lt;script&gt;</code> 标签，引入的script的内容中只有一个立即执行的方法，方法的名称即为第一步设定的方法名，方法的参数位<code>data</code>，传入相应的数据。</p><p><img src="http://markdown.img.esunr.xyz/a71efaafly1g2j93agwwyj20i505zaad.jpg"></p><h3 id="3-3-服务器端设置-http-header，"><a href="#3-3-服务器端设置-http-header，" class="headerlink" title="3.3 服务器端设置 http header，"></a>3.3 服务器端设置 http header，</h3><p><img src="http://markdown.img.esunr.xyz/20190507112512.png"></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="1-手动编写一个ajax，不依赖第三方库"><a href="#1-手动编写一个ajax，不依赖第三方库" class="headerlink" title="1. 手动编写一个ajax，不依赖第三方库"></a>1. 手动编写一个ajax，不依赖第三方库</h2><h2 id="2-跨域的几种实现方式"><a href="#2-跨域的几种实现方式" class="headerlink" title="2. 跨域的几种实现方式"></a>2. 跨域的几种实现方式</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探讨 Symbol-iterator 迭代器</title>
    <link href="/2021/12/4c279e95a858.html"/>
    <url>/2021/12/4c279e95a858.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-何为-Symbol-iterator"><a href="#1-何为-Symbol-iterator" class="headerlink" title="1. 何为 Symbol-iterator"></a>1. 何为 Symbol-iterator</h1><blockquote><p>Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</p></blockquote><p>ES6 定义了 <code>for...of</code> 方法，可以用来遍历数组的值，其用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br></code></pre></td></tr></table></figure><p>实际上 <code>for...of</code> 循环首先会向被访问的对象请求一个 <strong>迭代器对象</strong> ，然后通过调用迭代器对象的 <code>next()</code> 方法来遍历所有返回值。所谓的迭代器对象，就是指数组上本身所内置的 <code>@@iterator</code> ，我们可以通过访问数组的 <code>Symbol.iterator</code> 属性来取到该迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br>arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] <span class="hljs-comment">// [Function: values]</span><br></code></pre></td></tr></table></figure><p>我们可以利用其进行手动遍历数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">var</span> it = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>以下对象都内置了迭代器，也就是说他们可以直接使用 <code>for...of</code> 循环：</p><ul><li>Array.prototype<a href="">@@iterator</a></li><li>TypedArray.prototype<a href="">@@iterator</a></li><li>String.prototype<a href="">@@iterator</a></li><li>Map.prototype<a href="">@@iterator</a></li><li>Set.prototype<a href="">@@iterator</a></li></ul><p>此外，ES6 的展开运算符也是基于迭代器实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...a]) <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h1 id="2-迭代器的实现"><a href="#2-迭代器的实现" class="headerlink" title="2. 迭代器的实现"></a>2. 迭代器的实现</h1><p>对于一个普通的 Object 来说，由于其没有内置迭代器所以不能使用 <code>for...of</code> 循环，但是我们只要手动为其挂载上一个迭代器方法，并让其返回一个 <code>next()</code> 方法，每次调用 <code>next()</code> 方法是都返回一个包含 <code>value</code> 与 <code>done</code> 属相的对象，也可以实现对普通对象的 <code>for...of</code> 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;a&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;b&quot;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&quot;c&quot;</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> o = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(o);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: o[keys[index++]],<br>          <span class="hljs-attr">done</span>: index &gt; keys.<span class="hljs-property">length</span><br>        &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...obj])<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br><span class="hljs-selector-attr">[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ]</span><br></code></pre></td></tr></table></figure><p>顺带一提，迭代器每一步返回的过程是不是与 Generator 十分相似，我们先来复习一下 Generator 函数的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">yield</span> a++;<br>  <span class="hljs-keyword">yield</span> a++;<br>  <span class="hljs-keyword">yield</span> a++;<br>&#125;<br><br><span class="hljs-keyword">let</span> ge = <span class="hljs-title function_">generatorFn</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>所以利用 Generator 可以更加便捷的实现迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;a&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;b&quot;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&quot;c&quot;</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">// 注意 yeild 在这里只能使用 for 循环遍历，而不能使用 yield</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>[keys[i]];<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将本地项目托管到Github上，以及将Github上的项目同步到本地</title>
    <link href="/2021/12/602a7a9b73ae.html"/>
    <url>/2021/12/602a7a9b73ae.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发中我们经常会遇到这样的需求：在本地开发项目同步到Github上，同时将服务器上的代码也做更新。倘若能把 <code>本地-Github-服务器</code> 这三个平台关联（如图），这样就能极大的提高我们的效率。</p><p><img src="https://s2.loli.net/2023/04/22/wOzFbcxL1WoHvga.png"></p><p>那么大体上的思路就只分两步了：</p><ol><li>将本地项目托管到Github</li><li>将Github上的代码同步到远程服务器端</li></ol><h1 id="本地项目托管到Github"><a href="#本地项目托管到Github" class="headerlink" title="本地项目托管到Github"></a>本地项目托管到Github</h1><p>先假设我们再本地的D盘目录下创建了一个<code>test</code>文件夹，里面放着我们的项目代码，接下来我们需要进行如下操作将其托管到Github。</p><h3 id="1-本地下载安装Git环境"><a href="#1-本地下载安装Git环境" class="headerlink" title="1. 本地下载安装Git环境"></a>1. 本地下载安装Git环境</h3><p>这一步不多做赘述，去Git官网下载Git的安装包就可以了，安装完成后打开<code>Git Bash</code>应用，输入指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;yourEmail&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Generating public/private rsa key pair.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/c/Users/zpangxie/.ssh/id_rsa):</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Created directory <span class="hljs-string">&#x27;/c/Users/zpangxie/.ssh&#x27;</span>.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Enter same passphrase again:</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="hljs-string">&quot;yourName&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="hljs-string">&quot;yourEmal&quot;</span></span><br></code></pre></td></tr></table></figure><p><code>yourName</code>和<code>yourEmal</code>分别对应你的Github用户名和邮箱</p><h3 id="2-添加开发机的SSH-Key"><a href="#2-添加开发机的SSH-Key" class="headerlink" title="2. 添加开发机的SSH Key"></a>2. 添加开发机的SSH Key</h3><p><code>SSH Key</code>即SSH公钥，只有我们把某台PC的SSH公钥添加到Github的设置中，我们的这台PC才能跟我们上传的项目进行同步和更改。</p><p>首先我们打开Git Bash，在命令中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/.ssh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>如果列出如下目录：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">id_rsa</span>  id_rsa.pub  known_hosts<br></code></pre></td></tr></table></figure><p>说明已存在SSH Key无需再生成，如果不存在则运行</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh-keygen<br></code></pre></td></tr></table></figure><p>生成<code>id_rsa.pub</code>文件后，我们使用命令查看密钥</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure><p>得到的密钥大概长这样</p><p><img src="https://s2.loli.net/2023/04/22/jHBbVcumG45eCtR.png"></p><p>我们将<code>id_ras.pub</code>文件中的所有文本都复制下来，打开Github，选择右上角头像-Settings-SSH and GPG keys，点击选项面板中的<code>New SSH Key</code>。</p><p><img src="https://s2.loli.net/2023/04/22/ADPX1pEoZJ43yCM.png"></p><p>将自己的SSH Key添加到选项中即可，之后我们可以运行测试是否连接到Github</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>如果出现如下提示，则说名连接成功</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi Zpangxie! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><h3 id="3-在Github中创建空项目"><a href="#3-在Github中创建空项目" class="headerlink" title="3. 在Github中创建空项目"></a>3. 在Github中创建空项目</h3><p>我们点击右上角的“+”选择<code>New repository</code>创建一个新项目，要注意一点的是：</p><blockquote><p>新项目中除了题目和描述之外，不要点击任何选项，我们要的是一个完全空的项目仓库</p></blockquote><p><img src="https://s2.loli.net/2023/04/22/dy1zqZ3FUHxn857.png"></p><h3 id="4-上传本地项目代码到Github"><a href="#4-上传本地项目代码到Github" class="headerlink" title="4. 上传本地项目代码到Github"></a>4. 上传本地项目代码到Github</h3><p>我们点击<code>Create repository</code>之后，会出现一个提示，如下做讲解</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这一步是跳转到本地的项目目录，我们可以替换为cd指令跳转，cd C:/test<br>echo <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br><span class="hljs-regexp">//</span> 初始化项目<br>git init<br><span class="hljs-regexp">//</span> 添加一个README.md文件（选择性）<br>git add README.md<br><span class="hljs-regexp">//</span> 托管更改<br>git add . <br><span class="hljs-regexp">//</span> 提交一次初始化更改<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-regexp">//</span> 将本地与Github做远程连接<br>git remote add origin git@github.com:Zpangxie/test.git<br><span class="hljs-regexp">//</span> 提交代码到主分支<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>之后再刷新Github页面就发现代码提交完成了。</p><h1 id="Github代码同步到服务器"><a href="#Github代码同步到服务器" class="headerlink" title="Github代码同步到服务器"></a>Github代码同步到服务器</h1><blockquote><p>PS: 将代码下载到本地同理</p></blockquote><h3 id="1-服务器下载安装Git环境"><a href="#1-服务器下载安装Git环境" class="headerlink" title="1. 服务器下载安装Git环境"></a>1. 服务器下载安装Git环境</h3><p>与上文相同，只不过是服务器端就不需要用Git Bash了</p><h3 id="2-添加开发机的SSH-Key-1"><a href="#2-添加开发机的SSH-Key-1" class="headerlink" title="2. 添加开发机的SSH Key"></a>2. 添加开发机的SSH Key</h3><p>与上文相同</p><h3 id="4-同步项目代码到服务器（本地）"><a href="#4-同步项目代码到服务器（本地）" class="headerlink" title="4. 同步项目代码到服务器（本地）"></a>4. 同步项目代码到服务器（本地）</h3><p>首先在服务器或本地创建一个文件夹，作为项目的存放仓库，利用cd指令跳转到该文件夹下，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /var/www/html</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>初始化该目录为Git仓库</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git init<br></code></pre></td></tr></table></figure><p>我们在Github中打开我们的项目，之后选择<code>Clone or download</code>，复制我们项目的SSH地址</p><p><img src="https://s2.loli.net/2023/04/22/VCdth546ielnUqx.png"></p><p>将仓库远程源连接到Github上的该项目</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>Zpangxie/test.git<br></code></pre></td></tr></table></figure><blockquote><p>PS: 如过手滑信息填写错误，使用清除指令 <code>$ git remote remove origin</code> 清除源</p></blockquote><p>使用<code>Pull</code>指令，从远程源的主分支更新代码到服务器（本地）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git pull origin <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><p>完成。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue递归组件——树形组件的实现参考</title>
    <link href="/2021/12/690e0b6cfbcb.html"/>
    <url>/2021/12/690e0b6cfbcb.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-组件的调用方式"><a href="#1-组件的调用方式" class="headerlink" title="1. 组件的调用方式"></a>1. 组件的调用方式</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;template&gt;<br>  &lt;div class=<span class="hljs-string">&quot;tree&quot;</span>&gt;<br>    &lt;Tree <span class="hljs-punctuation">:</span>treeData=<span class="hljs-string">&quot;tree&quot;</span>&gt;&lt;/Tree&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Tree from <span class="hljs-string">&quot;./components/Tree&quot;</span>;<br>export default <span class="hljs-punctuation">&#123;</span><br>  components<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    Tree<br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  data() <span class="hljs-punctuation">&#123;</span><br>    return <span class="hljs-punctuation">&#123;</span><br>      tree<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>          title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>          next<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>              id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-1&quot;</span><span class="hljs-punctuation">,</span><br>              title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-1&quot;</span><span class="hljs-punctuation">,</span><br>              next<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-1-1&quot;</span><span class="hljs-punctuation">,</span><br>                  title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-1-1&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>              id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-2&quot;</span><span class="hljs-punctuation">,</span><br>              title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-2&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">,</span><br>          title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">,</span><br>          next<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>              id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-1&quot;</span><span class="hljs-punctuation">,</span><br>              title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-1&quot;</span><span class="hljs-punctuation">,</span><br>              next<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-1-1&quot;</span><span class="hljs-punctuation">,</span><br>                  title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-1-1&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>              id<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-2&quot;</span><span class="hljs-punctuation">,</span><br>              title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2-2&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span>;<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="2-父级组件"><a href="#2-父级组件" class="headerlink" title="2. 父级组件"></a>2. 父级组件</h1><p>父级组件组要是负责接受整个数据，遍历最外层的节点内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// components/Tree/index.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tree&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in treeData&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span> <span class="hljs-attr">:nodeData</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Item</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./subcomponents/Item&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tree&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Item</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;&#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">treeData</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scpoed</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.tree</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">20px</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="3-节点组件"><a href="#3-节点组件" class="headerlink" title="3. 节点组件"></a>3. 节点组件</h1><p>节点组件负责渲染节点本身，分为两种情况渲染：</p><ol><li>节点没有子节点，就输出单独一个节点内容</li><li>节点有子节点，渲染输出自己节点的内容同时，再循环遍历子节点的每个节点内容</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// components/Tree/subcomponents/Item.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;node&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nodeData.id&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;nodeData.next&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floder&quot;</span>&gt;</span>Floder : &#123;&#123; nodeData.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Node</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;subItem in nodeData.next&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;subItem.id&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:nodeData</span>=<span class="hljs-string">&quot;subItem&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;node&quot;</span> <span class="hljs-attr">v-else</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>file : &#123;&#123; nodeData.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Node&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;&#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">nodeData</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scope</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.node</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.floder</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">font-weight</span>: bold;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>后记：其实再 Item 组件中可以通过调用父级的 Tree 组件也可以实现对当前组件的递归调用。但是再 Vue 的子组件中如果调用父组件的话，会提示没有注册相应的组件，这应该是 Vue 为了防止组件循环调用而禁止了子组件去调用父组件吧。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Demo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 快速使用指南</title>
    <link href="/2021/03/41562c5845c9.html"/>
    <url>/2021/03/41562c5845c9.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p>(官方安装文档)[<a href="https://nginx.org/en/#basic_http_features]">https://nginx.org/en/#basic_http_features]</a></p><p>Install the prerequisites:</p><blockquote><p>sudo apt install curl gnupg2 ca-certificates lsb-release</p></blockquote><p>To set up the apt repository for stable nginx packages, run the following command:</p><blockquote><p>echo “deb <a href="http://nginx.org/packages/ubuntu">http://nginx.org/packages/ubuntu</a> `lsb_release -cs` nginx” \<br> | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nginx.list</p></blockquote><p>If you would like to use mainline nginx packages, run the following command instead:</p><blockquote><p>echo “deb <a href="http://nginx.org/packages/mainline/ubuntu">http://nginx.org/packages/mainline/ubuntu</a> `lsb_release -cs` nginx” \<br> | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nginx.list</p></blockquote><p>Next, import an official nginx signing key so apt could verify the packages authenticity:<br>ga</p><blockquote><p>curl -fsSL <a href="https://nginx.org/keys/nginx/_signing.key">https://nginx.org/keys/nginx\_signing.key</a> | sudo apt-key add -</p></blockquote><p>Verify that you now have the proper key:</p><blockquote><p>sudo apt-key fingerprint ABF5BD827BD9BF62</p></blockquote><p>The output should contain the full fingerprint <code>573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62</code> as follows:</p><blockquote><p>pub   rsa2048 2011-08-19 [SC] [expires: 2024-06-14]<br>   573B FD6B 3D8F BC64 1079  A6AB ABF5 BD82 7BD9 BF62<br>uid   [ unknown] nginx signing key &lt;signing-<a href="mailto:&#x6b;&#101;&#x79;&#x40;&#110;&#103;&#x69;&#110;&#x78;&#46;&#99;&#111;&#x6d;">&#x6b;&#101;&#x79;&#x40;&#110;&#103;&#x69;&#110;&#x78;&#46;&#99;&#111;&#x6d;</a>&gt;</p></blockquote><p>To install nginx, run the following commands:</p><blockquote><p>sudo apt update<br>sudo apt install nginx</p></blockquote><p>查看版本：</p><blockquote><p>nginx -v</p></blockquote><p>查看执行指令：</p><blockquote><p>nginx -V</p></blockquote><h1 id="2-主要配置文件"><a href="#2-主要配置文件" class="headerlink" title="2. 主要配置文件"></a>2. 主要配置文件</h1><p>安装成功后，配置文件存放于 <code>/etc/nginx</code> 目录下的 <code>nginx.conf</code> 文件中，默认配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-section">events</span> &#123;<br><span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br><span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Basic Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br><span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br><span class="hljs-comment"># server_tokens off;</span><br><br><span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br><span class="hljs-comment"># server_name_in_redirect off;</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br><span class="hljs-attribute">default_type</span> application/octet-stream;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># SSL Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Logging Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Gzip Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_disable</span> <span class="hljs-string">&quot;msie6&quot;</span>;<br><br><span class="hljs-comment"># gzip_vary on;</span><br><span class="hljs-comment"># gzip_proxied any;</span><br><span class="hljs-comment"># gzip_comp_level 6;</span><br><span class="hljs-comment"># gzip_buffers 16 8k;</span><br><span class="hljs-comment"># gzip_http_version 1.1;</span><br><span class="hljs-comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Virtual Host Configs</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br><span class="hljs-attribute">include</span> /etc/nginx/sites-enabled/*;<br>&#125;<br><br><br><span class="hljs-comment">#mail &#123;</span><br><span class="hljs-comment">## See sample authentication script at:</span><br><span class="hljs-comment">## http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">## auth_http localhost/auth.php;</span><br><span class="hljs-comment">## pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="hljs-comment">## imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:110;</span><br><span class="hljs-comment">#protocol   pop3;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:143;</span><br><span class="hljs-comment">#protocol   imap;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment">#&#125;</span><br></code></pre></td></tr></table></figure><p>在该文件中除了基础配置以外，又引入了两个配置文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 引入 <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span> 目录下的所有以 *.config 的文件<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>*.conf;<br># 引入 <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-enabled/</span> 目录下的所有文件<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-enabled/</span>*;<br></code></pre></td></tr></table></figure><p>我们将 <code>/etc/nginx</code> 目录结构输出，结果如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle">root@zpangxie_pc:<span class="hljs-regexp">/etc/</span>nginx# tree<br>.<br>├── conf.d<br>├── fastcgi.conf<br>├── fastcgi_params<br>├── koi-utf<br>├── koi-win<br>├── mime.types<br>├── nginx.conf<br>├── proxy_params<br>├── scgi_params<br>├── sites-available<br>│   └── <span class="hljs-keyword">default</span><br>├── sites-enabled<br>│   └── <span class="hljs-keyword">default</span> -&gt; <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-available/</span><span class="hljs-keyword">default</span><br>├── snippets<br>│   ├── fastcgi-php.conf<br>│   └── snakeoil.conf<br>├── uwsgi_params<br>└── win-utf<br></code></pre></td></tr></table></figure><p>sites-enabled 下创建了一个软连接，指向了 <code>/etc/nginx/sites-available/default</code>，这个文件就是默认的配置文件（注：根据不同的版本，有的版本的 nginx 默认配置文件存放于 <code>/etc/nginx/conf.d/default.conf</code> 中）。打开这个配置文件可以看到服务器相关的部分设置。</p><p>基础配置中，可以找到 nginx 服务器的根目录：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">root</span> /var/www/html;<br><br><span class="hljs-comment"># Add index.php to the list if you are using PHP</span><br><span class="hljs-attribute">index</span> index.html index.htm index.nginx-debian.html;<br><br><span class="hljs-attribute">server_name</span> _;<br><br><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-comment"># First attempt to serve request as file, then</span><br>  <span class="hljs-comment"># as directory, then fall back to displaying a 404.</span><br>  <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>部分版本的 nginx 配置为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">location</span> / &#123;<br>  root /usr/<span class="hljs-keyword">share</span>/nginx/html;<br>  <span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时我们可以指定 404 50x 的错误页面重定向，如设置一个重定向的 404 页面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;<br></code></pre></td></tr></table></figure><h1 id="3-Nginx-启动、停止与重启"><a href="#3-Nginx-启动、停止与重启" class="headerlink" title="3. Nginx 启动、停止与重启"></a>3. Nginx 启动、停止与重启</h1><p>启动 Nginx 服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nginx<br></code></pre></td></tr></table></figure><p>停止 Nginx 服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 从容停止</span><br><span class="hljs-variable">$ </span>nginx -s quit<br><br><span class="hljs-comment"># 立即停止</span><br><span class="hljs-variable">$ </span>nginx -s stop<br></code></pre></td></tr></table></figure><p>重启 nginx 服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nginx -s reload<br></code></pre></td></tr></table></figure><h1 id="4-访问权限"><a href="#4-访问权限" class="headerlink" title="4. 访问权限"></a>4. 访问权限</h1><p>限制某个 ip 不允许访问根目录：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">    deny</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>允许某个 ip 可以访问根目录：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br><span class="hljs-comment"># 127.0.0.1 ~ 127.0.0.100 都可以访问</span><br>    <span class="hljs-attribute">allow</span> <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">100</span>;<br>    <span class="hljs-attribute">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>权限判定是由上自下执行的，当 allow 与 deny 交换位置后，127.0.0.1&#x2F;100 也会被拒绝访问。</p></blockquote><p>如果想要精确控制某个路径，在路径前添加 <code>-</code> ：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 仅仅匹配访问 /img 目录时的请求</span><br><span class="hljs-keyword">location</span> <span class="hljs-title">-/img</span> &#123;<br>allow all;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用正则匹配：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 只要是以 .php 结尾的文件都不允许访问</span><br><span class="hljs-keyword">location</span> <span class="hljs-title">~\.php</span>$ &#123;<br><span class="hljs-keyword">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-虚拟主机"><a href="#5-虚拟主机" class="headerlink" title="5. 虚拟主机"></a>5. 虚拟主机</h1><p>虚拟主机的意思是在一台服务器上运行多个服务，通过配置，Nginx 可以帮助我们管理这些服务。通常在一个主机上运行多个服务的方案有：</p><ul><li>一台主机拥有一个域名，在同一个域名下配置多个端口，如 <code>zpangxie.top:8000</code> 可以访问 app1 <code>zpangxie.top:8001</code> 可以访问 app2，我们将其称为基于端口的配置方案。</li><li>一台主机拥有多个域名，用户访问不同的域名可以访问到不同的应用，如 <code>app1.zpangxie.top</code> 访问 app1，<code>app2.zpangxie.top</code> 访问 app2，我们将其称为基于域名的配置方案。</li></ul><h2 id="5-1-基于端口的配置方案"><a href="#5-1-基于端口的配置方案" class="headerlink" title="5.1 基于端口的配置方案"></a>5.1 基于端口的配置方案</h2><p>我们已知在  Nginx 配置目录下的<code>conf.d</code> 文件夹存放的配置文件都会被 Nginx 服务所读取。那么我们在该目录下创建 <code>8001.conf</code> 文件用于配置 8001 端口的服务：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>  <span class="hljs-comment"># 匹配端口为 8001 的请求</span><br>  listen <span class="hljs-number">8001</span>;<br>  root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span><span class="hljs-number">8001</span>;<br>  index index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建好如上的配置后，重启 Nginx 服务器，那么在 8001 端口也会被启用，起读取文件的根目录为 <code>/var/www/html/8001</code>。</p><p>当我们访问 <code>localhost:8001</code> 时：</p><p><img src="http://study.esunr.xyz/1583502962306.png"></p><h2 id="5-2-基于域名的配置方案"><a href="#5-2-基于域名的配置方案" class="headerlink" title="5.2 基于域名的配置方案"></a>5.2 基于域名的配置方案</h2><p>Nginx 服务默认运行在 80 端口，这个端口也是用户访问一个域名的默认端口号，所以最好不要向用户暴露端口号。Nginx 在接收用户请求时可以检查用户的 Host 字段，可以得知用户访问的域名是什么，于是我们就可以根据此项配置来将用户引导直不同的服务。</p><p>在配置文件中，可以设置 <code>server_name</code> 来配置不同域名的访问情况下，所读取的文件目录，以开头的例子为演示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 请求会根据配置自动匹配</span><br>server &#123;<br>  listen <span class="hljs-number">80</span>;<br>  server_name app1.zpangxie.top;<br>  root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>app1;<br>  index index.html<br>&#125;<br><br>server &#123;<br>  listen <span class="hljs-number">80</span>;<br>  server_name app2.zpangxie.top;<br>  root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>app2;<br>  index index.html<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当用访问 <code>app1.zpangxie.top</code> 时，就会返回服务器端的 <code>/var/www/html/app1/index.html</code>。当用户访问 <code>app2.zpangxie.top</code> 时，就会返回服务器端的 <code>/var/www/html/app2/index.html</code>。</p><h1 id="6-反向代理"><a href="#6-反向代理" class="headerlink" title="6. 反向代理"></a>6. 反向代理</h1><p>Nginx 拥有强大的反向代理功能，可以作为反向代理服务器使用。</p><blockquote><p>正向代理时代理客户端的请求，将多个客户端的请求转发到一台主机上，如 SSR 技术。</p><p>反向代理时代理服务器，一个用户访问代理服务器后，请求有可能被转发到多个服务器上，因此可被用作于负载均衡。</p></blockquote><p>我们可以做一个演示，当用户访问我们的域名时，我们利用 Nginx 的反向代理，将请求转发至 <code>https://www.baidu.com</code> 上：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span> test2.localhost.com;<br>  <span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> https://www.baidu.com;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，请求的域名并没有改变，但是实际的网页内容已经被替换为百度的内容：</p><p><img src="http://study.esunr.xyz/1583505904004.png"></p><h1 id="7-PC-端于移动端的适配"><a href="#7-PC-端于移动端的适配" class="headerlink" title="7. PC 端于移动端的适配"></a>7. PC 端于移动端的适配</h1><p>对于现阶段的移动端适配方案，通常有两种，分别为基于媒体查询器自适应网页，还有就是编写两套 web 端的页面。针对于第二种方案，Nginx 可以通过判断用户的访问设备类型，来自动返回给用户 PC 端的页面与移动端的页面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>  listen <span class="hljs-number">80</span>;<br>  server_name test.localhost.com;<br>  <span class="hljs-comment"># 匹配根目录</span><br>  location / &#123;<br>    root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>test.localhost.com;<br>    <span class="hljs-comment"># 如果时移动端设备，就返回移动端网页</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$http_user_agent</span> ~* <span class="hljs-string">&#x27;Android|webOS|iPhone|iPod|BlackBerry&#x27;</span>) &#123;<br>      root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/m</span>obile;<br>    &#125;<br>    index index.html;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://study.esunr.xyz/1583507504263.png" alt="移动端访问效果"></p><h1 id="8-Gzip-压缩"><a href="#8-Gzip-压缩" class="headerlink" title="8. Gzip 压缩"></a>8. Gzip 压缩</h1><p>gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。</p><p><strong>gzip的配置项</strong></p><p>Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。</p><ul><li>gzip : 该指令用于开启或 关闭gzip模块。</li><li>gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。</li><li>gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li><li>gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。</li><li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。</li><li>gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.</li><li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。</li><li>gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。</li></ul><p><strong>gzip最简单的配置</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">http &#123;<br>   .....<br>    gzip <span class="hljs-keyword">on</span>;<br>    gzip_types <span class="hljs-built_in">text</span>/plain <span class="hljs-built_in">application</span>/javascript <span class="hljs-built_in">text</span>/css;<br>   .....<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gzip on</code>是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。</p><p>配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>快速使用</tag>
      
      <tag>Nginx</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯CSS实现一个手风琴效果</title>
    <link href="/2020/12/770e185723fd.html"/>
    <url>/2020/12/770e185723fd.html</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在研究CSS选择器的时候，突然想到实现单个展开的手风琴效果很像 <code>radio</code> 组件，即单项选择组件，他们都是选择一个进入 selected 状态后，其他元素的 selected 状态就被取消。所以，对于表单的 <code>radio</code> 组件我们可以利用 CSS 伪类选择器 <code>:selected</code> 来检测其是否被选中。我们在 <code>radio</code> 旁边加一个兄弟节点作为手风琴面板展开显示的内容，默认设置为 <code>display: none</code>，然而当 <code>radio</code> 被选中后，就将其兄弟节点显示为 <code>display: block</code>。</p><p>同时，使用 <code>label</code> 标签，可以扩展 <code>radio</code> 组件的可选范围，使用 <code>visibility: hidden</code> 或者 <code>display: none</code> 可以隐藏原有的 <code>input</code> 标签样式。我们可以将 <code>label</code> 作为被点击对象的实例，而隐藏原有的 <code>input</code>，这样就可以进行美化。或者为 <code>input</code> 添加一个 <code>::after</code> 伪类元素，也可以起到同样的效果。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>我们按照上面的设想，实现一个简单的原型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">display</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span>+<span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-1&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    这是一串内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-2&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    这是一串内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-3&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    这是一串内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/72efwHKpYDSG56r.gif"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>为其添加样式与动画后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">label</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">135</span>, <span class="hljs-number">206</span>, <span class="hljs-number">235</span>);</span><br><span class="language-css">      <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">8</span>, <span class="hljs-number">181</span>, <span class="hljs-number">250</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">input</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">visibility</span>: hidden;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">      <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.2s</span> ease;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span>+<span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;form&gt; --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-1&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        这是一串内容<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-2&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        这是一串内容<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selector&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;radio-3&quot;</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio-3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        这是一串内容<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/01/JCL13wN6lfQKe28.gif"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
